{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/uniformBuffer.ts", "../../../dev/core/src/Lights/light.ts", "../../../dev/core/src/Lights/shadowLight.ts"],
  "sourcesContent": ["import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { IMatrixLike, IVector3Like, IVector4Like, IColor3Like, IColor4Like } from \"../Maths/math.like\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { InternalTexture } from \"./Textures/internalTexture\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Uniform buffer objects.\r\n *\r\n * Handles blocks of uniform on the GPU.\r\n *\r\n * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\r\n *\r\n * For more information, please refer to :\r\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n */\r\nexport class UniformBuffer {\r\n    /** @internal */\r\n    public static _UpdatedUbosInFrame: { [name: string]: number } = {};\r\n\r\n    private _engine: AbstractEngine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    private _buffers: Array<[DataBuffer, Float32Array | undefined]>;\r\n    private _bufferIndex: number;\r\n    private _createBufferOnWrite: boolean;\r\n    private _data: number[];\r\n    private _bufferData: Float32Array;\r\n    private _dynamic: boolean;\r\n    private _uniformLocations: { [key: string]: number };\r\n    private _uniformSizes: { [key: string]: number };\r\n    private _uniformArraySizes: { [key: string]: { strideSize: number; arraySize: number } };\r\n    private _uniformNames: string[] = [];\r\n    private _uniformLocationPointer: number;\r\n    private _needSync: boolean;\r\n    private _noUBO: boolean;\r\n    private _currentEffect: Effect;\r\n    private _currentEffectName: string;\r\n    private _name: string;\r\n    private _currentFrameId: number;\r\n    private _trackUBOsInFrame: boolean;\r\n\r\n    // Pool for avoiding memory leaks\r\n    private static _MAX_UNIFORM_SIZE = 256;\r\n    private static _TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\r\n    private static _TempBufferInt32View = new Int32Array(UniformBuffer._TempBuffer.buffer);\r\n    private static _TempBufferUInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);\r\n\r\n    /**\r\n     * Lambda to Update a 3x3 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix3x3: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 2x2 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix2x2: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a single float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat: (name: string, x: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloatArray: (name: string, array: Float32Array, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateArray: (name: string, array: number[]) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateIntArray: (name: string, array: Int32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUIntArray: (name: string, array: Uint32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix: (name: string, mat: IMatrixLike) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrices: (name: string, mat: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector3: (name: string, vector: IVector3Like) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector4: (name: string, vector: IVector4Like) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor3: (name: string, color: IColor3Like, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor4: (name: string, color: IColor3Like, alpha: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateDirectColor4: (name: string, color: IColor4Like, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a int a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt: (name: string, x: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a unsigned int a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt: (name: string, x: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Instantiates a new Uniform buffer objects.\r\n     *\r\n     * Handles blocks of uniform on the GPU.\r\n     *\r\n     * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\r\n     *\r\n     * For more information, please refer to :\r\n     * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n     * @param engine Define the engine the buffer is associated with\r\n     * @param data Define the data contained in the buffer\r\n     * @param dynamic Define if the buffer is updatable\r\n     * @param name to assign to the buffer (debugging purpose)\r\n     * @param forceNoUniformBuffer define that this object must not rely on UBO objects\r\n     * @param trackUBOsInFrame define if the UBOs should be tracked in the frame (default: undefined - will use the value from Engine._features.trackUbosInFrame)\r\n     */\r\n    constructor(engine: AbstractEngine, data?: number[], dynamic = false, name?: string, forceNoUniformBuffer = false, trackUBOsInFrame?: boolean) {\r\n        this._engine = engine;\r\n        this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;\r\n        this._dynamic = dynamic;\r\n        this._name = name ?? \"no-name\";\r\n\r\n        this._data = data || [];\r\n\r\n        this._uniformLocations = {};\r\n        this._uniformSizes = {};\r\n        this._uniformArraySizes = {};\r\n        this._uniformLocationPointer = 0;\r\n        this._needSync = false;\r\n        this._trackUBOsInFrame = false;\r\n\r\n        if ((trackUBOsInFrame === undefined && this._engine._features.trackUbosInFrame) || trackUBOsInFrame === true) {\r\n            this._buffers = [];\r\n            this._bufferIndex = -1;\r\n            this._createBufferOnWrite = false;\r\n            this._currentFrameId = 0;\r\n            this._trackUBOsInFrame = true;\r\n        }\r\n\r\n        if (this._noUBO) {\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\r\n            this.updateFloat = this._updateFloatForEffect;\r\n            this.updateFloat2 = this._updateFloat2ForEffect;\r\n            this.updateFloat3 = this._updateFloat3ForEffect;\r\n            this.updateFloat4 = this._updateFloat4ForEffect;\r\n            this.updateFloatArray = this._updateFloatArrayForEffect;\r\n            this.updateArray = this._updateArrayForEffect;\r\n            this.updateIntArray = this._updateIntArrayForEffect;\r\n            this.updateUIntArray = this._updateUIntArrayForEffect;\r\n            this.updateMatrix = this._updateMatrixForEffect;\r\n            this.updateMatrices = this._updateMatricesForEffect;\r\n            this.updateVector3 = this._updateVector3ForEffect;\r\n            this.updateVector4 = this._updateVector4ForEffect;\r\n            this.updateColor3 = this._updateColor3ForEffect;\r\n            this.updateColor4 = this._updateColor4ForEffect;\r\n            this.updateDirectColor4 = this._updateDirectColor4ForEffect;\r\n            this.updateInt = this._updateIntForEffect;\r\n            this.updateInt2 = this._updateInt2ForEffect;\r\n            this.updateInt3 = this._updateInt3ForEffect;\r\n            this.updateInt4 = this._updateInt4ForEffect;\r\n            this.updateUInt = this._updateUIntForEffect;\r\n            this.updateUInt2 = this._updateUInt2ForEffect;\r\n            this.updateUInt3 = this._updateUInt3ForEffect;\r\n            this.updateUInt4 = this._updateUInt4ForEffect;\r\n        } else {\r\n            this._engine._uniformBuffers.push(this);\r\n\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\r\n            this.updateFloat = this._updateFloatForUniform;\r\n            this.updateFloat2 = this._updateFloat2ForUniform;\r\n            this.updateFloat3 = this._updateFloat3ForUniform;\r\n            this.updateFloat4 = this._updateFloat4ForUniform;\r\n            this.updateFloatArray = this._updateFloatArrayForUniform;\r\n            this.updateArray = this._updateArrayForUniform;\r\n            this.updateIntArray = this._updateIntArrayForUniform;\r\n            this.updateUIntArray = this._updateUIntArrayForUniform;\r\n            this.updateMatrix = this._updateMatrixForUniform;\r\n            this.updateMatrices = this._updateMatricesForUniform;\r\n            this.updateVector3 = this._updateVector3ForUniform;\r\n            this.updateVector4 = this._updateVector4ForUniform;\r\n            this.updateColor3 = this._updateColor3ForUniform;\r\n            this.updateColor4 = this._updateColor4ForUniform;\r\n            this.updateDirectColor4 = this._updateDirectColor4ForUniform;\r\n            this.updateInt = this._updateIntForUniform;\r\n            this.updateInt2 = this._updateInt2ForUniform;\r\n            this.updateInt3 = this._updateInt3ForUniform;\r\n            this.updateInt4 = this._updateInt4ForUniform;\r\n            this.updateUInt = this._updateUIntForUniform;\r\n            this.updateUInt2 = this._updateUInt2ForUniform;\r\n            this.updateUInt3 = this._updateUInt3ForUniform;\r\n            this.updateUInt4 = this._updateUInt4ForUniform;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates if the buffer is using the WebGL2 UBO implementation,\r\n     * or just falling back on setUniformXXX calls.\r\n     */\r\n    public get useUbo(): boolean {\r\n        return !this._noUBO;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is in sync\r\n     * with the javascript cache data.\r\n     */\r\n    public get isSync(): boolean {\r\n        return !this._needSync;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is dynamic.\r\n     * Also, a dynamic UniformBuffer will disable cache verification and always\r\n     * update the underlying WebGL uniform buffer to the GPU.\r\n     * @returns if Dynamic, otherwise false\r\n     */\r\n    public isDynamic(): boolean {\r\n        return this._dynamic;\r\n    }\r\n\r\n    /**\r\n     * The data cache on JS side.\r\n     * @returns the underlying data as a float array\r\n     */\r\n    public getData(): Float32Array {\r\n        return this._bufferData;\r\n    }\r\n\r\n    /**\r\n     * The underlying WebGL Uniform buffer.\r\n     * @returns the webgl buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * The names of the uniforms in the buffer.\r\n     * @returns an array of uniform names\r\n     */\r\n    public getUniformNames(): string[] {\r\n        return this._uniformNames;\r\n    }\r\n\r\n    /**\r\n     * std140 layout specifies how to align data within an UBO structure.\r\n     * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\r\n     * for specs.\r\n     * @param size\r\n     */\r\n    private _fillAlignment(size: number) {\r\n        // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\r\n        // and 4x4 matrices\r\n        // TODO : change if other types are used\r\n\r\n        let alignment;\r\n        if (size <= 2) {\r\n            alignment = size;\r\n        } else {\r\n            alignment = 4;\r\n        }\r\n\r\n        if (this._uniformLocationPointer % alignment !== 0) {\r\n            const oldPointer = this._uniformLocationPointer;\r\n            this._uniformLocationPointer += alignment - (this._uniformLocationPointer % alignment);\r\n            const diff = this._uniformLocationPointer - oldPointer;\r\n\r\n            for (let i = 0; i < diff; i++) {\r\n                this._data.push(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds an uniform in the buffer.\r\n     * Warning : the subsequents calls of this function must be in the same order as declared in the shader\r\n     * for the layout to be correct ! The addUniform function only handles types like float, vec2, vec3, vec4, mat4,\r\n     * meaning size=1,2,3,4 or 16. It does not handle struct types.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param size Data size, or data directly.\r\n     * @param arraySize The number of elements in the array, 0 if not an array.\r\n     */\r\n    public addUniform(name: string, size: number | number[], arraySize = 0) {\r\n        if (arraySize > 0 && typeof size === \"number\") {\r\n            // Keep track of stride for `updateFloatArray`\r\n            this._uniformArraySizes[name] = { strideSize: size, arraySize };\r\n        }\r\n\r\n        if (this._uniformLocations[name] !== undefined) {\r\n            // Already existing uniform\r\n            return;\r\n        }\r\n\r\n        this._uniformNames.push(name);\r\n\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        // This function must be called in the order of the shader layout !\r\n        // size can be the size of the uniform, or data directly\r\n        let data;\r\n\r\n        // std140 FTW...\r\n        if (arraySize > 0) {\r\n            if (size instanceof Array) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"addUniform should not be use with Array in UBO: \" + name;\r\n            }\r\n\r\n            this._fillAlignment(4);\r\n\r\n            if (size == 16) {\r\n                size = size * arraySize;\r\n            } else {\r\n                const perElementPadding = 4 - size;\r\n                const totalPadding = perElementPadding * arraySize;\r\n                size = size * arraySize + totalPadding;\r\n            }\r\n\r\n            data = [];\r\n            // Fill with zeros\r\n            for (let i = 0; i < size; i++) {\r\n                data.push(0);\r\n            }\r\n        } else {\r\n            if (size instanceof Array) {\r\n                data = size;\r\n                size = data.length;\r\n            } else {\r\n                data = [];\r\n\r\n                // Fill with zeros\r\n                for (let i = 0; i < size; i++) {\r\n                    data.push(0);\r\n                }\r\n            }\r\n            this._fillAlignment(size);\r\n        }\r\n\r\n        this._uniformSizes[name] = size;\r\n        this._uniformLocations[name] = this._uniformLocationPointer;\r\n        this._uniformLocationPointer += size;\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            this._data.push(data[i]);\r\n        }\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 4x4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param mat A 4x4 matrix.\r\n     */\r\n    public addMatrix(name: string, mat: IMatrixLike) {\r\n        this.addUniform(name, Array.prototype.slice.call(mat.asArray()));\r\n    }\r\n\r\n    /**\r\n     * Adds a vec2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec2\r\n     * @param y Define the y component value of the vec2\r\n     */\r\n    public addFloat2(name: string, x: number, y: number) {\r\n        const temp = [x, y];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec3\r\n     * @param y Define the y component value of the vec3\r\n     * @param z Define the z component value of the vec3\r\n     */\r\n    public addFloat3(name: string, x: number, y: number, z: number) {\r\n        const temp = [x, y, z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the vec3 from a Color\r\n     */\r\n    public addColor3(name: string, color: IColor3Like) {\r\n        const temp = [color.r, color.g, color.b];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the rgb components from a Color\r\n     * @param alpha Define the a component of the vec4\r\n     */\r\n    public addColor4(name: string, color: IColor3Like, alpha: number) {\r\n        const temp = [color.r, color.g, color.b, alpha];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param vector Define the vec3 components from a Vector\r\n     */\r\n    public addVector3(name: string, vector: IVector3Like) {\r\n        const temp = [vector.x, vector.y, vector.z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 3x3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix3x3(name: string) {\r\n        this.addUniform(name, 12);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 2x2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix2x2(name: string) {\r\n        this.addUniform(name, 8);\r\n    }\r\n\r\n    /**\r\n     * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\r\n     */\r\n    public create(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n        if (this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        // See spec, alignment must be filled as a vec4\r\n        this._fillAlignment(4);\r\n        this._bufferData = new Float32Array(this._data);\r\n\r\n        this._rebuild();\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    // The result of this method is used for debugging purpose, as part of the buffer name\r\n    // It is meant to more easily know what this buffer is about when debugging\r\n    // Some buffers can have a lot of uniforms (several dozens), so the method only returns the first 10 of them\r\n    // (should be enough to understand what the buffer is for)\r\n    private _getNamesDebug() {\r\n        const names = [];\r\n        let i = 0;\r\n        for (const name in this._uniformLocations) {\r\n            names.push(name);\r\n            if (++i === 10) {\r\n                break;\r\n            }\r\n        }\r\n        return names.join(\",\");\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._noUBO || !this._bufferData) {\r\n            return;\r\n        }\r\n\r\n        if (this._dynamic) {\r\n            this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNamesDebug());\r\n        } else {\r\n            this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNamesDebug());\r\n        }\r\n\r\n        if (this._trackUBOsInFrame) {\r\n            this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : undefined]);\r\n            this._bufferIndex = this._buffers.length - 1;\r\n            this._createBufferOnWrite = false;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuildAfterContextLost(): void {\r\n        if (this._trackUBOsInFrame) {\r\n            this._buffers = [];\r\n            this._currentFrameId = 0;\r\n        }\r\n        this._rebuild();\r\n    }\r\n\r\n    /** @internal */\r\n    public get _numBuffers(): number {\r\n        return this._buffers.length;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _indexBuffer(): number {\r\n        return this._bufferIndex;\r\n    }\r\n\r\n    /** Gets or sets the name of this buffer */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    /** Gets the current effect */\r\n    public get currentEffect(): Nullable<Effect> {\r\n        return this._currentEffect;\r\n    }\r\n\r\n    private _buffersEqual(buf1: Float32Array, buf2: Float32Array): boolean {\r\n        for (let i = 0; i < buf1.length; ++i) {\r\n            if (buf1[i] !== buf2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _copyBuffer(src: Float32Array, dst: Float32Array): void {\r\n        for (let i = 0; i < src.length; ++i) {\r\n            dst[i] = src[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the WebGL Uniform Buffer on the GPU.\r\n     * If the `dynamic` flag is set to true, no cache comparison is done.\r\n     * Otherwise, the buffer will be updated only if the cache differs.\r\n     */\r\n    public update(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        this.bindUniformBuffer();\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n            return;\r\n        }\r\n\r\n        if (!this._dynamic && !this._needSync) {\r\n            this._createBufferOnWrite = this._trackUBOsInFrame;\r\n            return;\r\n        }\r\n\r\n        if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {\r\n            if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1]!)) {\r\n                this._needSync = false;\r\n                this._createBufferOnWrite = this._trackUBOsInFrame;\r\n                return;\r\n            } else {\r\n                this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]!);\r\n            }\r\n        }\r\n\r\n        this._engine.updateUniformBuffer(this._buffer, this._bufferData);\r\n\r\n        if (this._engine._features._collectUbosUpdatedInFrame) {\r\n            if (!UniformBuffer._UpdatedUbosInFrame[this._name]) {\r\n                UniformBuffer._UpdatedUbosInFrame[this._name] = 0;\r\n            }\r\n            UniformBuffer._UpdatedUbosInFrame[this._name]++;\r\n        }\r\n\r\n        this._needSync = false;\r\n        this._createBufferOnWrite = this._trackUBOsInFrame;\r\n    }\r\n\r\n    private _createNewBuffer() {\r\n        if (this._bufferIndex + 1 < this._buffers.length) {\r\n            this._bufferIndex++;\r\n            this._buffer = this._buffers[this._bufferIndex][0];\r\n            this._createBufferOnWrite = false;\r\n            this._needSync = true;\r\n        } else {\r\n            this._rebuild();\r\n        }\r\n    }\r\n\r\n    private _checkNewFrame(): void {\r\n        if (this._trackUBOsInFrame && this._currentFrameId !== this._engine.frameId) {\r\n            this._currentFrameId = this._engine.frameId;\r\n            this._createBufferOnWrite = false;\r\n            if (this._buffers && this._buffers.length > 0) {\r\n                this._needSync = this._bufferIndex !== 0;\r\n                this._bufferIndex = 0;\r\n                this._buffer = this._buffers[this._bufferIndex][0];\r\n            } else {\r\n                this._bufferIndex = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniform(uniformName: string, data: FloatArray, size: number) {\r\n        this._checkNewFrame();\r\n\r\n        let location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            if (this._buffer) {\r\n                // Cannot add an uniform if the buffer is already created\r\n                Logger.Error(\"Cannot add an uniform after UBO has been created. uniformName=\" + uniformName);\r\n                return;\r\n            }\r\n            this.addUniform(uniformName, size);\r\n            location = this._uniformLocations[uniformName];\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            let changed = false;\r\n\r\n            for (let i = 0; i < size; i++) {\r\n                // We are checking the matrix cache before calling updateUniform so we do not need to check it here\r\n                // Hence the test for size === 16 to simply commit the matrix values\r\n                if ((size === 16 && !this._engine._features.uniformBufferHardCheckMatrix) || this._bufferData[location + i] !== Math.fround(data[i])) {\r\n                    changed = true;\r\n                    if (this._createBufferOnWrite) {\r\n                        this._createNewBuffer();\r\n                    }\r\n                    this._bufferData[location + i] = data[i];\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (let i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniformArray(uniformName: string, data: FloatArray, size: number) {\r\n        this._checkNewFrame();\r\n\r\n        const location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            Logger.Error(\"Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.\");\r\n            return;\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        const arraySizes = this._uniformArraySizes[uniformName];\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            let changed = false;\r\n            let countToFour = 0;\r\n            let baseStride = 0;\r\n            for (let i = 0; i < size; i++) {\r\n                if (this._bufferData[location + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {\r\n                    changed = true;\r\n                    if (this._createBufferOnWrite) {\r\n                        this._createNewBuffer();\r\n                    }\r\n                    this._bufferData[location + baseStride * 4 + countToFour] = data[i];\r\n                }\r\n                countToFour++;\r\n                if (countToFour === arraySizes.strideSize) {\r\n                    for (; countToFour < 4; countToFour++) {\r\n                        this._bufferData[location + baseStride * 4 + countToFour] = 0;\r\n                    }\r\n                    countToFour = 0;\r\n                    baseStride++;\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (let i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Matrix cache\r\n    private _valueCache: { [key: string]: number } = {};\r\n    private _cacheMatrix(name: string, matrix: IMatrixLike): boolean {\r\n        this._checkNewFrame();\r\n\r\n        const cache = this._valueCache[name];\r\n        const flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[name] = flag;\r\n        return true;\r\n    }\r\n\r\n    // Update methods\r\n\r\n    private _updateMatrix3x3ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (let i = 0; i < 3; i++) {\r\n            UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];\r\n            UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\r\n            UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\r\n            UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 12);\r\n    }\r\n\r\n    private _updateMatrix3x3ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix3x3(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix2x2(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (let i = 0; i < 2; i++) {\r\n            UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];\r\n            UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\r\n            UniformBuffer._TempBuffer[i * 4 + 2] = 0.0;\r\n            UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 8);\r\n    }\r\n\r\n    private _updateFloatForEffect(name: string, x: number, suffix = \"\") {\r\n        this._currentEffect.setFloat(name + suffix, x);\r\n    }\r\n\r\n    private _updateFloatForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateFloat2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setFloat2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateFloat2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateFloat3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setFloat3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateFloat3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        UniformBuffer._TempBuffer[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateFloat4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setFloat4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateFloat4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        UniformBuffer._TempBuffer[2] = z;\r\n        UniformBuffer._TempBuffer[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateFloatArrayForEffect(name: string, array: Float32Array, suffix = \"\") {\r\n        switch (this._uniformArraySizes[name]?.strideSize) {\r\n            case 2:\r\n                this._currentEffect.setFloatArray2(name + suffix, array);\r\n                break;\r\n            case 3:\r\n                this._currentEffect.setFloatArray3(name + suffix, array);\r\n                break;\r\n            case 4:\r\n                this._currentEffect.setFloatArray4(name + suffix, array);\r\n                break;\r\n            default:\r\n                this._currentEffect.setFloatArray(name + suffix, array);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _updateFloatArrayForUniform(name: string, array: Float32Array) {\r\n        this.updateUniformArray(name, array, array.length);\r\n    }\r\n\r\n    private _updateArrayForEffect(name: string, array: number[]) {\r\n        this._currentEffect.setArray(name, array);\r\n    }\r\n\r\n    private _updateArrayForUniform(name: string, array: number[]) {\r\n        this.updateUniformArray(name, array, array.length);\r\n    }\r\n\r\n    private _updateIntArrayForEffect(name: string, array: Int32Array) {\r\n        this._currentEffect.setIntArray(name, array);\r\n    }\r\n\r\n    private _updateIntArrayForUniform(name: string, array: Int32Array) {\r\n        UniformBuffer._TempBufferInt32View.set(array);\r\n        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\r\n    }\r\n\r\n    private _updateUIntArrayForEffect(name: string, array: Uint32Array) {\r\n        this._currentEffect.setUIntArray(name, array);\r\n    }\r\n\r\n    private _updateUIntArrayForUniform(name: string, array: Uint32Array) {\r\n        UniformBuffer._TempBufferUInt32View.set(array);\r\n        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\r\n    }\r\n\r\n    private _updateMatrixForEffect(name: string, mat: IMatrixLike) {\r\n        this._currentEffect.setMatrix(name, mat);\r\n    }\r\n\r\n    private _updateMatrixForUniform(name: string, mat: IMatrixLike) {\r\n        if (this._cacheMatrix(name, mat)) {\r\n            this.updateUniform(name, <any>mat.asArray(), 16);\r\n        }\r\n    }\r\n\r\n    private _updateMatricesForEffect(name: string, mat: Float32Array) {\r\n        this._currentEffect.setMatrices(name, mat);\r\n    }\r\n\r\n    private _updateMatricesForUniform(name: string, mat: Float32Array) {\r\n        this.updateUniform(name, mat, mat.length);\r\n    }\r\n\r\n    private _updateVector3ForEffect(name: string, vector: IVector3Like) {\r\n        this._currentEffect.setVector3(name, vector);\r\n    }\r\n\r\n    private _updateVector3ForUniform(name: string, vector: IVector3Like) {\r\n        UniformBuffer._TempBuffer[0] = vector.x;\r\n        UniformBuffer._TempBuffer[1] = vector.y;\r\n        UniformBuffer._TempBuffer[2] = vector.z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateVector4ForEffect(name: string, vector: IVector4Like) {\r\n        this._currentEffect.setVector4(name, vector);\r\n    }\r\n\r\n    private _updateVector4ForUniform(name: string, vector: IVector4Like) {\r\n        UniformBuffer._TempBuffer[0] = vector.x;\r\n        UniformBuffer._TempBuffer[1] = vector.y;\r\n        UniformBuffer._TempBuffer[2] = vector.z;\r\n        UniformBuffer._TempBuffer[3] = vector.w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateColor3ForEffect(name: string, color: IColor3Like, suffix = \"\") {\r\n        this._currentEffect.setColor3(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor3ForUniform(name: string, color: IColor3Like) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateColor4ForEffect(name: string, color: IColor3Like, alpha: number, suffix = \"\") {\r\n        this._currentEffect.setColor4(name + suffix, color, alpha);\r\n    }\r\n\r\n    private _updateDirectColor4ForEffect(name: string, color: IColor4Like, suffix = \"\") {\r\n        this._currentEffect.setDirectColor4(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor4ForUniform(name: string, color: IColor3Like, alpha: number) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        UniformBuffer._TempBuffer[3] = alpha;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateDirectColor4ForUniform(name: string, color: IColor4Like) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        UniformBuffer._TempBuffer[3] = color.a;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateIntForEffect(name: string, x: number, suffix = \"\") {\r\n        this._currentEffect.setInt(name + suffix, x);\r\n    }\r\n\r\n    private _updateIntForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateInt2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setInt2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateInt2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateInt3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setInt3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateInt3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        UniformBuffer._TempBufferInt32View[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateInt4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setInt4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateInt4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        UniformBuffer._TempBufferInt32View[2] = z;\r\n        UniformBuffer._TempBufferInt32View[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateUIntForEffect(name: string, x: number, suffix = \"\") {\r\n        this._currentEffect.setUInt(name + suffix, x);\r\n    }\r\n\r\n    private _updateUIntForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateUInt2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setUInt2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateUInt2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateUInt3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setUInt3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateUInt3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        UniformBuffer._TempBufferUInt32View[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateUInt4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setUInt4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateUInt4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        UniformBuffer._TempBufferUInt32View[2] = z;\r\n        UniformBuffer._TempBufferUInt32View[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    /**\r\n     * Sets a sampler uniform on the effect.\r\n     * @param name Define the name of the sampler.\r\n     * @param texture Define the texture to set in the sampler\r\n     */\r\n    public setTexture(name: string, texture: Nullable<ThinTexture>) {\r\n        this._currentEffect.setTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of sampler uniforms on the effect.\r\n     * @param name Define the name of uniform.\r\n     * @param textures Define the textures to set in the array of samplers\r\n     */\r\n    public setTextureArray(name: string, textures: ThinTexture[]) {\r\n        this._currentEffect.setTextureArray(name, textures);\r\n    }\r\n    /**\r\n     * Sets a sampler uniform on the effect.\r\n     * @param name Define the name of the sampler.\r\n     * @param texture Define the (internal) texture to set in the sampler\r\n     */\r\n    public bindTexture(name: string, texture: Nullable<InternalTexture>) {\r\n        this._currentEffect._bindTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Directly updates the value of the uniform in the cache AND on the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     */\r\n    public updateUniformDirectly(uniformName: string, data: FloatArray) {\r\n        this.updateUniform(uniformName, data, data.length);\r\n\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Associates an effect to this uniform buffer\r\n     * @param effect Define the effect to associate the buffer to\r\n     * @param name Name of the uniform block in the shader.\r\n     */\r\n    public bindToEffect(effect: Effect, name: string): void {\r\n        this._currentEffect = effect;\r\n        this._currentEffectName = name;\r\n    }\r\n\r\n    /**\r\n     * Binds the current (GPU) buffer to the effect\r\n     */\r\n    public bindUniformBuffer(): void {\r\n        if (!this._noUBO && this._buffer && this._currentEffect) {\r\n            this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dissociates the current effect from this uniform buffer\r\n     */\r\n    public unbindEffect(): void {\r\n        this._currentEffect = undefined as any;\r\n        this._currentEffectName = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Sets the current state of the class (_bufferIndex, _buffer) to point to the data buffer passed in parameter if this buffer is one of the buffers handled by the class (meaning if it can be found in the _buffers array)\r\n     * This method is meant to be able to update a buffer at any time: just call setDataBuffer to set the class in the right state, call some updateXXX methods and then call udpate() => that will update the GPU buffer on the graphic card\r\n     * @param dataBuffer buffer to look for\r\n     * @returns true if the buffer has been found and the class internal state points to it, else false\r\n     */\r\n    public setDataBuffer(dataBuffer: DataBuffer): boolean {\r\n        if (!this._buffers) {\r\n            return this._buffer === dataBuffer;\r\n        }\r\n\r\n        for (let b = 0; b < this._buffers.length; ++b) {\r\n            const buffer = this._buffers[b];\r\n            if (buffer[0] === dataBuffer) {\r\n                this._bufferIndex = b;\r\n                this._buffer = dataBuffer;\r\n                this._createBufferOnWrite = false;\r\n                this._currentEffect = undefined as any;\r\n                // Note that if _buffers.length == 1, we don't copy _bufferData into _buffers[_bufferIndex][1] (see the update() method), and _bufferData already contains the right data\r\n                if (this._buffers.length > 1 && this._buffers[b][1]) {\r\n                    this._bufferData.set(this._buffers[b][1]!);\r\n                }\r\n                this._valueCache = {};\r\n                // The following line prevents the current buffer (_buffer / _bufferIndex) from being updated during subsequent calls to updateXXX() due to a call to _checkNewFrame()\r\n                // If we called setDataBuffer, it means that we want to update the buffer we just defined and not another one (_checkNewFrame() can modify the current buffer).\r\n                this._currentFrameId = this._engine.frameId;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the uniform buffer has a uniform with the given name.\r\n     * @param name Name of the uniform to check\r\n     * @returns True if the uniform exists, false otherwise.\r\n     */\r\n    public has(name: string): boolean {\r\n        return this._uniformLocations[name] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Disposes the uniform buffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        const uniformBuffers = this._engine._uniformBuffers;\r\n        const index = uniformBuffers.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\r\n            uniformBuffers.pop();\r\n        }\r\n\r\n        if (this._trackUBOsInFrame && this._buffers) {\r\n            for (let i = 0; i < this._buffers.length; ++i) {\r\n                const buffer = this._buffers[i][0];\r\n                this._engine._releaseBuffer(buffer);\r\n            }\r\n        } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {\r\n            this._buffer = null;\r\n        }\r\n    }\r\n}\r\n", "import { serialize, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { ISortableLight } from \"./lightConstants\";\r\nimport { LightConstants } from \"./lightConstants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node implements ISortableLight {\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n\r\n    /**\r\n     * Light type const id of the area light.\r\n     */\r\n    public static readonly LIGHTTYPEID_RECT_AREALIGHT = LightConstants.LIGHTTYPEID_RECT_AREALIGHT;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is not affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    /** @internal */\r\n    public _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Returns the view matrix.\r\n     * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.\r\n     * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getViewMatrix(_faceIndex?: number): Nullable<Matrix> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the projection matrix.\r\n     * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).\r\n     * @param _viewMatrix The view transform matrix of the light (optional).\r\n     * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).\r\n     * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getProjectionMatrix(_viewMatrix?: Matrix, _renderList?: Array<AbstractMesh>): Nullable<Matrix> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Shadow generators associated to the light.\r\n     * @internal Internal use only.\r\n     */\r\n    public _shadowGenerators: Nullable<Map<Nullable<Camera>, IShadowGenerator>> = null;\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light uniform buffer.\r\n     * @internal Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    private _lastUseSpecular: boolean;\r\n\r\n    /**\r\n     * Used internally by ClusteredLight to sort lights\r\n     * @internal\r\n     */\r\n    public _currentViewDepth = 0;\r\n\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene, false);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = [] as AbstractMesh[];\r\n        this.excludedMeshes = [] as AbstractMesh[];\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        const iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n            this._lastUseSpecular = useSpecular;\r\n\r\n            const scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\r\n            const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        } else {\r\n            this._uniformBuffer.bindUniformBuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public override toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\", \"Clustered\"][this.getTypeID()];\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @internal */\r\n    protected override _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public override setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\r\n     * @returns the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(camera: Nullable<Camera> = null): Nullable<IShadowGenerator> {\r\n        if (this._shadowGenerators === null) {\r\n            return null;\r\n        }\r\n\r\n        return this._shadowGenerators.get(camera) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Returns all the shadow generators associated to this light\r\n     * @returns\r\n     */\r\n    public getShadowGenerators(): Nullable<Map<Nullable<Camera>, IShadowGenerator>> {\r\n        return this._shadowGenerators;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @returns true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.dispose();\r\n            }\r\n            this._shadowGenerators = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.lights.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.lights.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Remove from meshes\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @param newParent The parent of this light, if it has one\r\n     * @returns the new created light\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node> = null): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        const clonedLight = SerializationHelper.Clone(constructor, this);\r\n        if (name) {\r\n            clonedLight.name = name;\r\n        }\r\n        if (newParent) {\r\n            clonedLight.parent = newParent;\r\n        }\r\n        clonedLight.setEnabled(this.isEnabled());\r\n\r\n        this.onClonedObservable.notifyObservers(clonedLight);\r\n\r\n        return clonedLight;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            for (const mesh of this.excludedMeshes) {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            }\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            for (const mesh of this.includedOnlyMeshes) {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId !== undefined) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        if (parsedLight.parentInstanceIndex !== undefined) {\r\n            light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedLight.isEnabled !== undefined) {\r\n            light.setEnabled(parsedLight.isEnabled);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            for (const item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (const item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (const item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @internal Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * @returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        const lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE: {\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemispheric light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @internal Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        const scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _isReady() {\r\n        return true;\r\n    }\r\n}\r\n", "import { serialize, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n/**\r\n * Interface describing all the common properties and methods a shadow light needs to implement.\r\n * This helps both the shadow generator and materials to generate the corresponding shadow maps\r\n * as well as binding the different shadow properties to the effects.\r\n */\r\nexport interface IShadowLight extends Light {\r\n    /**\r\n     * The light id in the scene (used in scene.getLightById for instance)\r\n     */\r\n    id: string;\r\n    /**\r\n     * The position the shadow will be casted from.\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * In 2d mode (needCube being false), the direction used to cast the shadow.\r\n     */\r\n    direction: Vector3;\r\n    /**\r\n     * The transformed position. Position of the light in world space taking parenting in account.\r\n     */\r\n    transformedPosition: Vector3;\r\n    /**\r\n     * The transformed direction. Direction of the light in world space taking parenting in account.\r\n     */\r\n    transformedDirection: Vector3;\r\n    /**\r\n     * The friendly name of the light in the scene.\r\n     */\r\n    name: string;\r\n    /**\r\n     * Defines the shadow projection clipping minimum z value.\r\n     */\r\n    shadowMinZ: number;\r\n    /**\r\n     * Defines the shadow projection clipping maximum z value.\r\n     */\r\n    shadowMaxZ: number;\r\n\r\n    /**\r\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n     */\r\n    computeTransformedInformation(): boolean;\r\n\r\n    /**\r\n     * Gets the scene the light belongs to.\r\n     * @returns The scene\r\n     */\r\n    getScene(): Scene;\r\n\r\n    /**\r\n     * Callback defining a custom Projection Matrix Builder.\r\n     * This can be used to override the default projection matrix computation.\r\n     */\r\n    customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;\r\n\r\n    /**\r\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n     * @param matrix The matrix to update with the projection information\r\n     * @param viewMatrix The transform matrix of the light\r\n     * @param renderList The list of mesh to render in the map\r\n     * @returns The current light\r\n     */\r\n    setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight;\r\n\r\n    /**\r\n     * Gets the current depth scale used in ESM.\r\n     * @returns The scale\r\n     */\r\n    getDepthScale(): number;\r\n\r\n    /**\r\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n     * @returns true if a cube texture needs to be use\r\n     */\r\n    needCube(): boolean;\r\n\r\n    /**\r\n     * Detects if the projection matrix requires to be recomputed this frame.\r\n     * @returns true if it requires to be recomputed otherwise, false.\r\n     */\r\n    needProjectionMatrixCompute(): boolean;\r\n\r\n    /**\r\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n     */\r\n    forceProjectionMatrixCompute(): void;\r\n\r\n    /**\r\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    getShadowDirection(faceIndex?: number): Vector3;\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    getDepthMinZ(activeCamera: Nullable<Camera>): number;\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    getDepthMaxZ(activeCamera: Nullable<Camera>): number;\r\n}\r\n\r\n/**\r\n * Base implementation IShadowLight\r\n * It groups all the common behaviour in order to reduce duplication and better follow the DRY pattern.\r\n */\r\nexport abstract class ShadowLight extends Light implements IShadowLight {\r\n    protected abstract _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;\r\n\r\n    protected _position: Vector3;\r\n    protected _setPosition(value: Vector3) {\r\n        this._position = value;\r\n    }\r\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\r\n    @serializeAsVector3()\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\r\n    public set position(value: Vector3) {\r\n        this._setPosition(value);\r\n    }\r\n\r\n    protected _direction: Vector3;\r\n    protected _setDirection(value: Vector3) {\r\n        this._direction = value;\r\n    }\r\n    /**\r\n     * In 2d mode (needCube being false), gets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\r\n    @serializeAsVector3()\r\n    public get direction(): Vector3 {\r\n        return this._direction;\r\n    }\r\n    /**\r\n     * In 2d mode (needCube being false), sets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\r\n    public set direction(value: Vector3) {\r\n        this._setDirection(value);\r\n    }\r\n\r\n    protected _shadowMinZ: number;\r\n    /**\r\n     * Gets the shadow projection clipping minimum z value.\r\n     */\r\n    @serialize()\r\n    public get shadowMinZ(): number {\r\n        return this._shadowMinZ;\r\n    }\r\n    /**\r\n     * Sets the shadow projection clipping minimum z value.\r\n     */\r\n    public set shadowMinZ(value: number) {\r\n        this._shadowMinZ = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    protected _shadowMaxZ: number;\r\n    /**\r\n     * Sets the shadow projection clipping maximum z value.\r\n     */\r\n    @serialize()\r\n    public get shadowMaxZ(): number {\r\n        return this._shadowMaxZ;\r\n    }\r\n    /**\r\n     * Gets the shadow projection clipping maximum z value.\r\n     */\r\n    public set shadowMaxZ(value: number) {\r\n        this._shadowMaxZ = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Callback defining a custom Projection Matrix Builder.\r\n     * This can be used to override the default projection matrix computation.\r\n     */\r\n    public customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;\r\n\r\n    /**\r\n     * The transformed position. Position of the light in world space taking parenting in account. Needs to be computed by calling computeTransformedInformation.\r\n     */\r\n    public transformedPosition: Vector3;\r\n\r\n    /**\r\n     * The transformed direction. Direction of the light in world space taking parenting in account.\r\n     */\r\n    public transformedDirection: Vector3;\r\n\r\n    private _needProjectionMatrixCompute: boolean = true;\r\n\r\n    /**\r\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n     */\r\n    public computeTransformedInformation(): boolean {\r\n        if (this.parent && this.parent.getWorldMatrix) {\r\n            if (!this.transformedPosition) {\r\n                this.transformedPosition = Vector3.Zero();\r\n            }\r\n            Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);\r\n\r\n            // In case the direction is present.\r\n            if (this.direction) {\r\n                if (!this.transformedDirection) {\r\n                    this.transformedDirection = Vector3.Zero();\r\n                }\r\n                Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return the depth scale used for the shadow map.\r\n     * @returns the depth scale.\r\n     */\r\n    public getDepthScale(): number {\r\n        return 50.0;\r\n    }\r\n\r\n    /**\r\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getShadowDirection(faceIndex?: number): Vector3 {\r\n        return this.transformedDirection ? this.transformedDirection : this.direction;\r\n    }\r\n\r\n    /**\r\n     * If computeTransformedInformation has been called, returns the ShadowLight absolute position in the world. Otherwise, returns the local position.\r\n     * @returns the position vector in world space\r\n     */\r\n    public override getAbsolutePosition(): Vector3 {\r\n        return this.transformedPosition ? this.transformedPosition : this.position;\r\n    }\r\n\r\n    /**\r\n     * Sets the ShadowLight direction toward the passed target.\r\n     * @param target The point to target in local space\r\n     * @returns the updated ShadowLight direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(this.position));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the light rotation in euler definition.\r\n     * @returns the x y z rotation in local space.\r\n     */\r\n    public getRotation(): Vector3 {\r\n        this.direction.normalize();\r\n        const xaxis = Vector3.Cross(this.direction, Axis.Y);\r\n        const yaxis = Vector3.Cross(xaxis, this.direction);\r\n        return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n     * @returns true if a cube texture needs to be use\r\n     */\r\n    public needCube(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Detects if the projection matrix requires to be recomputed this frame.\r\n     * @returns true if it requires to be recomputed otherwise, false.\r\n     */\r\n    public needProjectionMatrixCompute(): boolean {\r\n        return this._needProjectionMatrixCompute;\r\n    }\r\n\r\n    /**\r\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n     */\r\n    public forceProjectionMatrixCompute(): void {\r\n        this._needProjectionMatrixCompute = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _initCache() {\r\n        super._initCache();\r\n\r\n        this._cache.position = Vector3.Zero();\r\n    }\r\n\r\n    /** @internal */\r\n    public override _isSynchronized(): boolean {\r\n        if (!this._cache.position.equals(this.position)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @returns the world matrix\r\n     */\r\n    public override computeWorldMatrix(force?: boolean): Matrix {\r\n        if (!force && this.isSynchronized()) {\r\n            this._currentRenderId = this.getScene().getRenderId();\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        this._updateCache();\r\n        this._cache.position.copyFrom(this.position);\r\n\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);\r\n\r\n        if (this.parent && this.parent.getWorldMatrix) {\r\n            this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);\r\n\r\n            this._markSyncedWithParent();\r\n        }\r\n\r\n        // Cache the determinant\r\n        this._worldMatrixDeterminantIsDirty = true;\r\n\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    public getDepthMinZ(activeCamera: Nullable<Camera>): number {\r\n        return this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera?.minZ || Constants.ShadowMinZ;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    public getDepthMaxZ(activeCamera: Nullable<Camera>): number {\r\n        return this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera?.maxZ || Constants.ShadowMaxZ;\r\n    }\r\n\r\n    /**\r\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n     * @param matrix The matrix to updated with the projection information\r\n     * @param viewMatrix The transform matrix of the light\r\n     * @param renderList The list of mesh to render in the map\r\n     * @returns The current light\r\n     */\r\n    public setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight {\r\n        if (this.customProjectionMatrixBuilder) {\r\n            this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);\r\n        } else {\r\n            this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    protected override _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.parent || !this.parent.getWorldMatrix) {\r\n            (this.transformedPosition as any) = null;\r\n            (this.transformedDirection as any) = null;\r\n        }\r\n    }\r\n\r\n    protected _viewMatrix: Matrix = Matrix.Identity();\r\n    protected _projectionMatrix: Matrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Returns the view matrix.\r\n     * @param faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.\r\n     * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public override getViewMatrix(faceIndex?: number): Nullable<Matrix> {\r\n        const lightDirection = TmpVectors.Vector3[0];\r\n\r\n        let lightPosition = this.position;\r\n        if (this.computeTransformedInformation()) {\r\n            lightPosition = this.transformedPosition;\r\n        }\r\n\r\n        Vector3.NormalizeToRef(this.getShadowDirection(faceIndex), lightDirection);\r\n        if (Math.abs(Vector3.Dot(lightDirection, Vector3.Up())) === 1.0) {\r\n            lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\r\n        }\r\n\r\n        const lightTarget = TmpVectors.Vector3[1];\r\n        lightPosition.addToRef(lightDirection, lightTarget);\r\n\r\n        Matrix.LookAtLHToRef(lightPosition, lightTarget, Vector3.Up(), this._viewMatrix);\r\n\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the projection matrix.\r\n     * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).\r\n     * @param viewMatrix The view transform matrix of the light (optional).\r\n     * @param renderList The list of meshes to take into account when calculating the projection matrix (optional).\r\n     * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public override getProjectionMatrix(viewMatrix?: Matrix, renderList?: Array<AbstractMesh>): Nullable<Matrix> {\r\n        this.setShadowProjectionMatrix(this._projectionMatrix, viewMatrix ?? this._viewMatrix, renderList ?? []);\r\n\r\n        return this._projectionMatrix;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}

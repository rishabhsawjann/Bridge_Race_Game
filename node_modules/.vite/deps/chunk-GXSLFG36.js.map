{
  "version": 3,
  "sources": ["../../../dev/core/src/Lights/spotLight.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts", "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts"],
  "sourcesContent": ["import { serialize, serializeAsTexture } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { ProceduralTexture } from \"../Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_2\", (name, scene) => {\r\n    return () => new SpotLight(name, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);\r\n});\r\n\r\n/**\r\n * A spot light is defined by a position, a direction, an angle, and an exponent.\r\n * These values define a cone of light starting from the position, emitting toward the direction.\r\n * The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,\r\n * and the exponent defines the speed of the decay of the light with distance (reach).\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class SpotLight extends ShadowLight {\r\n    /*\r\n        upVector , rightVector and direction will form the coordinate system for this spot light.\r\n        These three vectors will be used as projection matrix when doing texture projection.\r\n\r\n        Also we have the following rules always holds:\r\n        direction cross up   = right\r\n        right cross direction = up\r\n        up cross right       = forward\r\n\r\n        light_near and light_far will control the range of the texture projection. If a plane is\r\n        out of the range in spot light space, there is no texture projection.\r\n    */\r\n\r\n    private _angle: number;\r\n    private _innerAngle: number = 0;\r\n    /** @internal */\r\n    public _cosHalfAngle: number;\r\n\r\n    /** @internal */\r\n    public _lightAngleScale: number;\r\n    /** @internal */\r\n    public _lightAngleOffset: number;\r\n\r\n    private _iesProfileTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Gets or sets the IES profile texture used to create the spotlight\r\n     * @see https://playground.babylonjs.com/#UIAXAU#1\r\n     */\r\n    public get iesProfileTexture(): Nullable<BaseTexture> {\r\n        return this._iesProfileTexture;\r\n    }\r\n\r\n    public set iesProfileTexture(value: Nullable<BaseTexture>) {\r\n        if (this._iesProfileTexture === value) {\r\n            return;\r\n        }\r\n\r\n        this._iesProfileTexture = value;\r\n\r\n        if (this._iesProfileTexture && SpotLight._IsTexture(this._iesProfileTexture)) {\r\n            this._iesProfileTexture.onLoadObservable.addOnce(() => {\r\n                this._markMeshesAsLightDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the cone angle of the spot light in Radians.\r\n     */\r\n    @serialize()\r\n    public get angle(): number {\r\n        return this._angle;\r\n    }\r\n    /**\r\n     * Sets the cone angle of the spot light in Radians.\r\n     */\r\n    public set angle(value: number) {\r\n        this._angle = value;\r\n        this._cosHalfAngle = Math.cos(value * 0.5);\r\n        this._projectionTextureProjectionLightDirty = true;\r\n        this.forceProjectionMatrixCompute();\r\n        this._computeAngleValues();\r\n    }\r\n\r\n    /**\r\n     * Only used in gltf falloff mode, this defines the angle where\r\n     * the directional falloff will start before cutting at angle which could be seen\r\n     * as outer angle.\r\n     */\r\n    @serialize()\r\n    public get innerAngle(): number {\r\n        return this._innerAngle;\r\n    }\r\n    /**\r\n     * Only used in gltf falloff mode, this defines the angle where\r\n     * the directional falloff will start before cutting at angle which could be seen\r\n     * as outer angle.\r\n     */\r\n    public set innerAngle(value: number) {\r\n        this._innerAngle = value;\r\n        this._computeAngleValues();\r\n    }\r\n\r\n    private _shadowAngleScale: number;\r\n    /**\r\n     * Allows scaling the angle of the light for shadow generation only.\r\n     */\r\n    @serialize()\r\n    public get shadowAngleScale(): number {\r\n        return this._shadowAngleScale;\r\n    }\r\n    /**\r\n     * Allows scaling the angle of the light for shadow generation only.\r\n     */\r\n    public set shadowAngleScale(value: number) {\r\n        this._shadowAngleScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * The light decay speed with the distance from the emission spot.\r\n     */\r\n    @serialize()\r\n    public exponent: number;\r\n\r\n    private _projectionTextureMatrix = Matrix.Zero();\r\n    /**\r\n     * Allows reading the projection texture\r\n     */\r\n    public get projectionTextureMatrix(): Matrix {\r\n        return this._projectionTextureMatrix;\r\n    }\r\n\r\n    protected _projectionTextureLightNear: number = 1e-6;\r\n    /**\r\n     * Gets the near clip of the Spotlight for texture projection.\r\n     */\r\n    @serialize()\r\n    public get projectionTextureLightNear(): number {\r\n        return this._projectionTextureLightNear;\r\n    }\r\n    /**\r\n     * Sets the near clip of the Spotlight for texture projection.\r\n     */\r\n    public set projectionTextureLightNear(value: number) {\r\n        this._projectionTextureLightNear = value;\r\n        this._projectionTextureProjectionLightDirty = true;\r\n    }\r\n\r\n    protected _projectionTextureLightFar: number = 1000.0;\r\n    /**\r\n     * Gets the far clip of the Spotlight for texture projection.\r\n     */\r\n    @serialize()\r\n    public get projectionTextureLightFar(): number {\r\n        return this._projectionTextureLightFar;\r\n    }\r\n    /**\r\n     * Sets the far clip of the Spotlight for texture projection.\r\n     */\r\n    public set projectionTextureLightFar(value: number) {\r\n        this._projectionTextureLightFar = value;\r\n        this._projectionTextureProjectionLightDirty = true;\r\n    }\r\n\r\n    protected _projectionTextureUpDirection: Vector3 = Vector3.Up();\r\n    /**\r\n     * Gets the Up vector of the Spotlight for texture projection.\r\n     */\r\n    @serialize()\r\n    public get projectionTextureUpDirection(): Vector3 {\r\n        return this._projectionTextureUpDirection;\r\n    }\r\n    /**\r\n     * Sets the Up vector of the Spotlight for texture projection.\r\n     */\r\n    public set projectionTextureUpDirection(value: Vector3) {\r\n        this._projectionTextureUpDirection = value;\r\n        this._projectionTextureProjectionLightDirty = true;\r\n    }\r\n\r\n    @serializeAsTexture(\"projectedLightTexture\")\r\n    private _projectionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets the projection texture of the light.\r\n     */\r\n    public get projectionTexture(): Nullable<BaseTexture> {\r\n        return this._projectionTexture;\r\n    }\r\n    /**\r\n     * Sets the projection texture of the light.\r\n     */\r\n    public set projectionTexture(value: Nullable<BaseTexture>) {\r\n        if (this._projectionTexture === value) {\r\n            return;\r\n        }\r\n        this._projectionTexture = value;\r\n        this._projectionTextureDirty = true;\r\n        if (this._projectionTexture && !this._projectionTexture.isReady()) {\r\n            if (SpotLight._IsProceduralTexture(this._projectionTexture)) {\r\n                this._projectionTexture.getEffect().executeWhenCompiled(() => {\r\n                    this._markMeshesAsLightDirty();\r\n                });\r\n            } else if (SpotLight._IsTexture(this._projectionTexture)) {\r\n                this._projectionTexture.onLoadObservable.addOnce(() => {\r\n                    this._markMeshesAsLightDirty();\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsProceduralTexture(texture: BaseTexture): texture is ProceduralTexture {\r\n        return (texture as ProceduralTexture).onGeneratedObservable !== undefined;\r\n    }\r\n\r\n    private static _IsTexture(texture: BaseTexture): texture is Texture {\r\n        return (texture as Texture).onLoadObservable !== undefined;\r\n    }\r\n\r\n    private _projectionTextureViewLightDirty = true;\r\n    private _projectionTextureProjectionLightDirty = true;\r\n    private _projectionTextureDirty = true;\r\n    private _projectionTextureViewTargetVector = Vector3.Zero();\r\n    private _projectionTextureViewLightMatrix = Matrix.Zero();\r\n\r\n    private _projectionTextureProjectionLightMatrix = Matrix.Zero();\r\n    /**\r\n     * Gets or sets the light projection matrix as used by the projection texture\r\n     */\r\n    public get projectionTextureProjectionLightMatrix(): Matrix {\r\n        return this._projectionTextureProjectionLightMatrix;\r\n    }\r\n\r\n    public set projectionTextureProjectionLightMatrix(projection: Matrix) {\r\n        this._projectionTextureProjectionLightMatrix = projection;\r\n        this._projectionTextureProjectionLightDirty = false;\r\n        this._projectionTextureDirty = true;\r\n    }\r\n\r\n    private _projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);\r\n\r\n    /**\r\n     * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The light friendly name\r\n     * @param position The position of the spot light in the scene\r\n     * @param direction The direction of the light in the scene\r\n     * @param angle The cone angle of the light in Radians\r\n     * @param exponent The light decay speed with the distance from the emission spot\r\n     * @param scene The scene the lights belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, direction: Vector3, angle: number, exponent: number, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.position = position;\r\n        this.direction = direction;\r\n        this.angle = angle;\r\n        this.exponent = exponent;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SpotLight\".\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"SpotLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 2.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public override getTypeID(): number {\r\n        return Light.LIGHTTYPEID_SPOTLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Overrides the direction setter to recompute the projection texture view light Matrix.\r\n     * @param value\r\n     */\r\n    protected override _setDirection(value: Vector3) {\r\n        super._setDirection(value);\r\n        this._projectionTextureViewLightDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Overrides the position setter to recompute the projection texture view light Matrix.\r\n     * @param value\r\n     */\r\n    protected override _setPosition(value: Vector3) {\r\n        super._setPosition(value);\r\n        this._projectionTextureViewLightDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.\r\n     * Returns the SpotLight.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        this._shadowAngleScale = this._shadowAngleScale || 1;\r\n        const angle = this._shadowAngleScale * this._angle;\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.PerspectiveFovLHToRef(\r\n            angle,\r\n            1.0,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            true,\r\n            this._scene.getEngine().isNDCHalfZRange,\r\n            undefined,\r\n            useReverseDepthBuffer\r\n        );\r\n    }\r\n\r\n    protected _computeProjectionTextureViewLightMatrix(): void {\r\n        this._projectionTextureViewLightDirty = false;\r\n        this._projectionTextureDirty = true;\r\n\r\n        this.getAbsolutePosition().addToRef(this.getShadowDirection(), this._projectionTextureViewTargetVector);\r\n        Matrix.LookAtLHToRef(this.getAbsolutePosition(), this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);\r\n    }\r\n\r\n    protected _computeProjectionTextureProjectionLightMatrix(): void {\r\n        this._projectionTextureProjectionLightDirty = false;\r\n        this._projectionTextureDirty = true;\r\n\r\n        const lightFar = this.projectionTextureLightFar;\r\n        const lightNear = this.projectionTextureLightNear;\r\n\r\n        const p = lightFar / (lightFar - lightNear);\r\n        const q = -p * lightNear;\r\n        const s = 1.0 / Math.tan(this._angle / 2.0);\r\n        const a = 1.0;\r\n\r\n        Matrix.FromValuesToRef(s / a, 0.0, 0.0, 0.0, 0.0, s, 0.0, 0.0, 0.0, 0.0, p, 1.0, 0.0, 0.0, q, 0.0, this._projectionTextureProjectionLightMatrix);\r\n    }\r\n\r\n    /**\r\n     * Main function for light texture projection matrix computing.\r\n     */\r\n    protected _computeProjectionTextureMatrix(): void {\r\n        this._projectionTextureDirty = false;\r\n\r\n        this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);\r\n        if (this._projectionTexture instanceof Texture) {\r\n            const u = this._projectionTexture.uScale / 2.0;\r\n            const v = this._projectionTexture.vScale / 2.0;\r\n            Matrix.FromValuesToRef(u, 0.0, 0.0, 0.0, 0.0, v, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0, this._projectionTextureScalingMatrix);\r\n        }\r\n        this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDirection\", 3);\r\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    private _computeAngleValues(): void {\r\n        this._lightAngleScale = 1.0 / Math.max(0.001, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);\r\n        this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public override transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        if (this.projectionTexture && this.projectionTexture.isReady()) {\r\n            if (this._projectionTextureViewLightDirty) {\r\n                this._computeProjectionTextureViewLightMatrix();\r\n            }\r\n            if (this._projectionTextureProjectionLightDirty) {\r\n                this._computeProjectionTextureProjectionLightMatrix();\r\n            }\r\n            if (this._projectionTextureDirty) {\r\n                this._computeProjectionTextureMatrix();\r\n            }\r\n            effect.setMatrix(\"textureProjectionMatrix\" + lightIndex, this._projectionTextureMatrix);\r\n            effect.setTexture(\"projectionLightTexture\" + lightIndex, this.projectionTexture);\r\n        }\r\n\r\n        if (this._iesProfileTexture && this._iesProfileTexture.isReady()) {\r\n            effect.setTexture(\"iesLightTexture\" + lightIndex, this._iesProfileTexture);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the SpotLight transformed position (or position if not parented) and normalized direction.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The spot light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): SpotLight {\r\n        let normalizeDirection;\r\n\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\r\n                \"vLightData\",\r\n                this.transformedPosition.x - this._scene.floatingOriginOffset.x,\r\n                this.transformedPosition.y - this._scene.floatingOriginOffset.y,\r\n                this.transformedPosition.z - this._scene.floatingOriginOffset.z,\r\n                this.exponent,\r\n                lightIndex\r\n            );\r\n\r\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\r\n        } else {\r\n            this._uniformBuffer.updateFloat4(\r\n                \"vLightData\",\r\n                this.position.x - this._scene.floatingOriginOffset.x,\r\n                this.position.y - this._scene.floatingOriginOffset.y,\r\n                this.position.z - this._scene.floatingOriginOffset.z,\r\n                this.exponent,\r\n                lightIndex\r\n            );\r\n\r\n            normalizeDirection = Vector3.Normalize(this.direction);\r\n        }\r\n\r\n        this._uniformBuffer.updateFloat4(\"vLightDirection\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);\r\n\r\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        let normalizeDirection;\r\n\r\n        if (this.computeTransformedInformation()) {\r\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\r\n        } else {\r\n            normalizeDirection = Vector3.Normalize(this.direction);\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);\r\n        } else {\r\n            effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes the light and the associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n        if (this._projectionTexture) {\r\n            this._projectionTexture.dispose();\r\n        }\r\n        if (this._iesProfileTexture) {\r\n            this._iesProfileTexture.dispose();\r\n            this._iesProfileTexture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    public override getDepthMinZ(activeCamera: Nullable<Camera>): number {\r\n        const engine = this._scene.getEngine();\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : (activeCamera?.minZ ?? Constants.ShadowMinZ);\r\n\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? minZ : this._scene.getEngine().isNDCHalfZRange ? 0 : minZ;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    public override getDepthMaxZ(activeCamera: Nullable<Camera>): number {\r\n        const engine = this._scene.getEngine();\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : (activeCamera?.maxZ ?? Constants.ShadowMaxZ);\r\n\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : maxZ;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"SPOTLIGHT\" + lightIndex] = true;\r\n        defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;\r\n        defines[\"IESLIGHTTEXTURE\" + lightIndex] = this._iesProfileTexture && this._iesProfileTexture.isReady() ? true : false;\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.SpotLight\", SpotLight);\r\n", "import type { IObjectInfo, IPathToObjectConverter } from \"core/ObjectModel/objectModelInterfaces\";\r\nimport type { IGLTF } from \"../glTFLoaderInterfaces\";\r\nimport type { IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\r\n\r\n/**\r\n * Adding an exception here will break traversing through the glTF object tree.\r\n * This is used for properties that might not be in the glTF object model, but are optional and have a default value.\r\n * For example, the path /nodes/\\{\\}/extensions/KHR_node_visibility/visible is optional - the object can be deferred without the object fully existing.\r\n */\r\nexport const OptionalPathExceptionsList: {\r\n    regex: RegExp;\r\n}[] = [\r\n    {\r\n        // get the node as object when reading an extension\r\n        regex: new RegExp(`^/nodes/\\\\d+/extensions/`),\r\n    },\r\n];\r\n\r\n/**\r\n * A converter that takes a glTF Object Model JSON Pointer\r\n * and transforms it into an ObjectAccessorContainer, allowing\r\n * objects referenced in the glTF to be associated with their\r\n * respective Babylon.js objects.\r\n */\r\nexport class GLTFPathToObjectConverter<T, BabylonType, BabylonValue> implements IPathToObjectConverter<IObjectAccessor<T, BabylonType, BabylonValue>> {\r\n    public constructor(\r\n        private _gltf: IGLTF,\r\n        private _infoTree: any\r\n    ) {}\r\n\r\n    /**\r\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\r\n     * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers\r\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\r\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\r\n     * <assetIndex> := <digit> | <name>\r\n     * <propertyPath> := <extensionPath> | <standardPath>\r\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\r\n     * <standardPath> := <name> | <name>/<standardPath>\r\n     * <name> := W+\r\n     * <digit> := D+\r\n     *\r\n     * Examples:\r\n     *  - \"/nodes/0/rotation\"\r\n     * - \"/nodes.length\"\r\n     *  - \"/materials/2/emissiveFactor\"\r\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\r\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\r\n     *\r\n     * @param path The path to convert\r\n     * @returns The object and info associated with the path\r\n     */\r\n    public convert(path: string): IObjectInfo<IObjectAccessor<T, BabylonType, BabylonValue>> {\r\n        let objectTree: any = this._gltf;\r\n        let infoTree: any = this._infoTree;\r\n        let target: any = undefined;\r\n\r\n        if (!path.startsWith(\"/\")) {\r\n            throw new Error(\"Path must start with a /\");\r\n        }\r\n        const parts = path.split(\"/\");\r\n        parts.shift();\r\n\r\n        //if the last part has \".length\" in it, separate that as an extra part\r\n        if (parts[parts.length - 1].includes(\".length\")) {\r\n            const lastPart = parts[parts.length - 1];\r\n            const split = lastPart.split(\".\");\r\n            parts.pop();\r\n            parts.push(...split);\r\n        }\r\n\r\n        let ignoreObjectTree = false;\r\n\r\n        for (const part of parts) {\r\n            const isLength = part === \"length\";\r\n            if (isLength && !infoTree.__array__) {\r\n                throw new Error(`Path ${path} is invalid`);\r\n            }\r\n            if (infoTree.__ignoreObjectTree__) {\r\n                ignoreObjectTree = true;\r\n            }\r\n            if (infoTree.__array__ && !isLength) {\r\n                infoTree = infoTree.__array__;\r\n            } else {\r\n                infoTree = infoTree[part];\r\n                if (!infoTree) {\r\n                    throw new Error(`Path ${path} is invalid`);\r\n                }\r\n            }\r\n            if (!ignoreObjectTree) {\r\n                if (objectTree === undefined) {\r\n                    // check if the path is in the exception list. If it is, break and return the last object that was found\r\n                    const exception = OptionalPathExceptionsList.find((e) => e.regex.test(path));\r\n                    if (!exception) {\r\n                        throw new Error(`Path ${path} is invalid`);\r\n                    }\r\n                } else if (!isLength) {\r\n                    objectTree = objectTree?.[part];\r\n                }\r\n            }\r\n\r\n            if (infoTree.__target__ || isLength) {\r\n                target = objectTree;\r\n            }\r\n        }\r\n\r\n        return {\r\n            object: target,\r\n            info: infoTree,\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nimport type { TransformNode } from \"core/Meshes/transformNode\";\nimport type { IAnimation, ICamera, IGLTF, IKHRLightsPunctual_Light, IMaterial, IMesh, INode } from \"../glTFLoaderInterfaces\";\nimport type { Vector3 } from \"core/Maths/math.vector\";\nimport { Matrix, Quaternion, Vector2 } from \"core/Maths/math.vector\";\nimport { Constants } from \"core/Engines/constants\";\nimport type { Color3 } from \"core/Maths/math.color\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\nimport type { Light } from \"core/Lights/light\";\nimport type { Nullable } from \"core/types\";\nimport { SpotLight } from \"core/Lights/spotLight\";\nimport type { IEXTLightsImageBased_LightImageBased } from \"babylonjs-gltf2interface\";\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\nimport type { IInterpolationPropertyInfo, IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\nimport { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\nimport type { Mesh } from \"core/Meshes/mesh\";\n\nexport interface IGLTFObjectModelTree {\n    cameras: IGLTFObjectModelTreeCamerasObject;\n    nodes: IGLTFObjectModelTreeNodesObject;\n    materials: IGLTFObjectModelTreeMaterialsObject;\n    extensions: IGLTFObjectModelTreeExtensionsObject;\n    animations: {\n        length: IObjectAccessor<IAnimation[], AnimationGroup[], number>;\n        __array__: {};\n    };\n    meshes: {\n        length: IObjectAccessor<IMesh[], (Mesh | undefined)[], number>;\n        __array__: {};\n    };\n}\n\nexport interface IGLTFObjectModelTreeNodesObject<GLTFTargetType = INode, BabylonTargetType = TransformNode> {\n    length: IObjectAccessor<GLTFTargetType[], BabylonTargetType[], number>;\n    __array__: {\n        __target__: boolean;\n        translation: IObjectAccessor<GLTFTargetType, BabylonTargetType, Vector3>;\n        rotation: IObjectAccessor<GLTFTargetType, BabylonTargetType, Quaternion>;\n        scale: IObjectAccessor<GLTFTargetType, BabylonTargetType, Vector3>;\n        matrix: IObjectAccessor<GLTFTargetType, BabylonTargetType, Matrix>;\n        globalMatrix: IObjectAccessor<GLTFTargetType, BabylonTargetType, Matrix>;\n        weights: {\n            length: IObjectAccessor<GLTFTargetType, BabylonTargetType, number>;\n            __array__: { __target__: boolean } & IObjectAccessor<GLTFTargetType, BabylonTargetType, number>;\n        } & IObjectAccessor<GLTFTargetType, BabylonTargetType, number[]>;\n        extensions: {\n            EXT_lights_ies?: {\n                multiplier: IObjectAccessor<INode, Light, number>;\n                color: IObjectAccessor<INode, Light, Color3>;\n            };\n        };\n    };\n}\n\nexport interface IGLTFObjectModelTreeCamerasObject {\n    __array__: {\n        __target__: boolean;\n        orthographic: {\n            xmag: IObjectAccessor<ICamera, ICamera, Vector2>;\n            ymag: IObjectAccessor<ICamera, ICamera, Vector2>;\n            zfar: IObjectAccessor<ICamera, ICamera, number>;\n            znear: IObjectAccessor<ICamera, ICamera, number>;\n        };\n        perspective: {\n            yfov: IObjectAccessor<ICamera, ICamera, number>;\n            zfar: IObjectAccessor<ICamera, ICamera, number>;\n            znear: IObjectAccessor<ICamera, ICamera, number>;\n            aspectRatio: IObjectAccessor<ICamera, ICamera, Nullable<number>>;\n        };\n    };\n}\n\nexport interface IGLTFObjectModelTreeMaterialsObject {\n    __array__: {\n        __target__: boolean;\n        pbrMetallicRoughness: {\n            baseColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color4>;\n            metallicFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<number>>;\n            roughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<number>>;\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: ITextureDefinition;\n                };\n            };\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: ITextureDefinition;\n                };\n            };\n        };\n        emissiveFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n        normalTexture: {\n            scale: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        occlusionTexture: {\n            strength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                anisotropyRotation: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_clearcoat: {\n                clearcoatFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                clearcoatRoughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                clearcoatNormalTexture: {\n                    scale: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_dispersion: {\n                dispersion: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_emissive_strength: {\n                emissiveStrength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_ior: {\n                ior: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_iridescence: {\n                iridescenceFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceIor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceThicknessMinimum: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceThicknessMaximum: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_sheen: {\n                sheenColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                sheenRoughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_specular: {\n                specularFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                specularColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_transmission: {\n                transmissionFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                diffuseTransmissionColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<Color3>>;\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_volume: {\n                thicknessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                attenuationColor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                attenuationDistance: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n        };\n    };\n}\n\ninterface ITextureDefinition {\n    offset: IObjectAccessor<IMaterial, PBRMaterial, Vector2>;\n    rotation: IObjectAccessor<IMaterial, PBRMaterial, number>;\n    scale: IObjectAccessor<IMaterial, PBRMaterial, Vector2>;\n}\n\nexport interface IGLTFObjectModelTreeMeshesObject {}\n\nexport interface IGLTFObjectModelTreeExtensionsObject {\n    KHR_lights_punctual: {\n        lights: {\n            length: IObjectAccessor<IKHRLightsPunctual_Light[], Light[], number>;\n            __array__: {\n                __target__: boolean;\n                color: IObjectAccessor<IKHRLightsPunctual_Light, Light, Color3>;\n                intensity: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                range: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                spot: {\n                    innerConeAngle: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                    outerConeAngle: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                };\n            };\n        };\n    };\n    EXT_lights_ies: {\n        lights: {\n            length: IObjectAccessor<IKHRLightsPunctual_Light[], Light[], number>;\n        };\n    };\n    EXT_lights_image_based: {\n        lights: {\n            __array__: {\n                __target__: boolean;\n                intensity: IObjectAccessor<IEXTLightsImageBased_LightImageBased, BaseTexture, number>;\n                rotation: IObjectAccessor<IEXTLightsImageBased_LightImageBased, BaseTexture, Quaternion>;\n            };\n            length: IObjectAccessor<IEXTLightsImageBased_LightImageBased[], BaseTexture[], number>;\n        };\n    };\n}\n\nconst nodesTree: IGLTFObjectModelTreeNodesObject = {\n    length: {\n        type: \"number\",\n        get: (nodes: INode[]) => nodes.length,\n        getTarget: (nodes: INode[]) => nodes.map((node) => node._babylonTransformNode!),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {\n        __target__: true,\n        translation: {\n            type: \"Vector3\",\n            get: (node: INode) => node._babylonTransformNode?.position,\n            set: (value: Vector3, node: INode) => node._babylonTransformNode?.position.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"position\"],\n        },\n        rotation: {\n            type: \"Quaternion\",\n            get: (node: INode) => node._babylonTransformNode?.rotationQuaternion!,\n            set: (value: Quaternion, node: INode) => node._babylonTransformNode?.rotationQuaternion?.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"rotationQuaternion\"],\n        },\n        scale: {\n            type: \"Vector3\",\n            get: (node: INode) => node._babylonTransformNode?.scaling,\n            set: (value: Vector3, node: INode) => node._babylonTransformNode?.scaling.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"scaling\"],\n        },\n        weights: {\n            length: {\n                type: \"number\",\n                get: (node: INode) => node._numMorphTargets,\n                getTarget: (node: INode) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            __array__: {\n                __target__: true,\n                type: \"number\",\n                get: (node: INode, index?: number) => (index !== undefined ? node._primitiveBabylonMeshes?.[0].morphTargetManager?.getTarget(index).influence : undefined),\n                // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n                getTarget: (node: INode) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            type: \"number[]\",\n            get: (node: INode, index?: number) => [0], // TODO: get the weights correctly\n            // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"influence\"],\n        },\n        // readonly!\n        matrix: {\n            type: \"Matrix\",\n            get: (node: INode) => Matrix.Compose(node._babylonTransformNode?.scaling!, node._babylonTransformNode?.rotationQuaternion!, node._babylonTransformNode?.position!),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        globalMatrix: {\n            type: \"Matrix\",\n            get: (node: INode) => {\n                const matrix = Matrix.Identity();\n                // RHS/LHS support\n                let rootNode = node.parent;\n                while (rootNode && rootNode.parent) {\n                    rootNode = rootNode.parent;\n                }\n                const forceUpdate =\n                    node._babylonTransformNode?.position._isDirty || node._babylonTransformNode?.rotationQuaternion?._isDirty || node._babylonTransformNode?.scaling._isDirty;\n                if (rootNode) {\n                    // take the parent root node's world matrix, invert it, and multiply it with the current node's world matrix\n                    // This will provide the global matrix, ignoring the RHS->LHS conversion\n                    const rootMatrix = rootNode._babylonTransformNode?.computeWorldMatrix(true).invert();\n                    if (rootMatrix) {\n                        node._babylonTransformNode?.computeWorldMatrix(forceUpdate)?.multiplyToRef(rootMatrix, matrix);\n                    }\n                } else if (node._babylonTransformNode) {\n                    matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));\n                }\n                return matrix;\n            },\n            getTarget: (node: INode) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        extensions: {\n            EXT_lights_ies: {\n                multiplier: {\n                    type: \"number\",\n                    get: (node: INode) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.intensity;\n                    },\n                    getTarget: (node: INode) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.intensity = value;\n                            }\n                        }\n                    },\n                },\n                color: {\n                    type: \"Color3\",\n                    get: (node: INode) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.diffuse;\n                    },\n                    getTarget: (node: INode) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node: INode) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.diffuse = value;\n                            }\n                        }\n                    },\n                },\n            },\n        },\n    },\n};\n\nconst animationsTree = {\n    length: {\n        type: \"number\",\n        get: (animations: IAnimation[]) => animations.length,\n        getTarget: (animations: IAnimation[]) => animations.map((animation) => animation._babylonAnimationGroup!),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\n\nconst meshesTree = {\n    length: {\n        type: \"number\",\n        get: (meshes: IMesh[]) => meshes.length,\n        getTarget: (meshes: IMesh[]) => meshes.map((mesh) => mesh.primitives[0]._instanceData?.babylonSourceMesh),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\n\nconst camerasTree: IGLTFObjectModelTreeCamerasObject = {\n    __array__: {\n        __target__: true,\n        orthographic: {\n            xmag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoLeft ?? 0, camera._babylonCamera?.orthoRight ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoLeft = value.x;\n                        camera._babylonCamera.orthoRight = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoLeft\", () => \"orthoRight\"],\n            },\n            ymag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera: ICamera) => new Vector2(camera._babylonCamera?.orthoBottom ?? 0, camera._babylonCamera?.orthoTop ?? 0),\n                set: (value: Vector2, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoBottom = value.x;\n                        camera._babylonCamera.orthoTop = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoBottom\", () => \"orthoTop\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.maxZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.minZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n        perspective: {\n            aspectRatio: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.getEngine().getAspectRatio(camera._babylonCamera),\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"aspectRatio\"],\n                isReadOnly: true, // might not be the case for glTF?\n            },\n            yfov: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.fov,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.fov = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"fov\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.maxZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.minZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n    },\n};\n\nconst materialsTree: IGLTFObjectModelTreeMaterialsObject = {\n    __array__: {\n        __target__: true,\n        emissiveFactor: {\n            type: \"Color3\",\n            get: (material, index?, payload?) => GetMaterial(material, index, payload).emissiveColor,\n            set: (value: Color3, material, index?, payload?) => GetMaterial(material, index, payload).emissiveColor.copyFrom(value),\n            getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n            getPropertyName: [() => \"emissiveColor\"],\n        },\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"emissiveTexture\"),\n            },\n        },\n        normalTexture: {\n            scale: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetTexture(material, payload, \"bumpTexture\")?.level,\n                set: (value: number, material, index?, payload?) => {\n                    const texture = GetTexture(material, payload, \"bumpTexture\");\n                    if (texture) {\n                        texture.level = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"level\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"bumpTexture\"),\n            },\n        },\n        occlusionTexture: {\n            strength: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).ambientTextureStrength,\n                set: (value: number, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.ambientTextureStrength = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"ambientTextureStrength\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"ambientTexture\"),\n            },\n        },\n        pbrMetallicRoughness: {\n            baseColorFactor: {\n                type: \"Color4\",\n                get: (material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    return Color4.FromColor3(mat.albedoColor, mat.alpha);\n                },\n                set: (value: Color4, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    mat.albedoColor.set(value.r, value.g, value.b);\n                    mat.alpha = value.a;\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                // This is correct on the animation level, but incorrect as a single property of a type Color4\n                getPropertyName: [() => \"albedoColor\", () => \"alpha\"],\n            },\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"albedoTexture\"),\n                },\n            },\n            metallicFactor: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).metallic,\n                set: (value, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.metallic = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"metallic\"],\n            },\n            roughnessFactor: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).roughness,\n                set: (value, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.roughness = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"roughness\"],\n            },\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"metallicTexture\"),\n                },\n            },\n        },\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).anisotropy.intensity,\n                    set: (value: number, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).anisotropy.intensity = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.intensity\"],\n                },\n                anisotropyRotation: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).anisotropy.angle,\n                    set: (value: number, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).anisotropy.angle = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.angle\"],\n                },\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"anisotropy\", \"texture\"),\n                    },\n                },\n            },\n            KHR_materials_clearcoat: {\n                clearcoatFactor: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).clearCoat.intensity,\n                    set: (value, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).clearCoat.intensity = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.intensity\"],\n                },\n                clearcoatRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).clearCoat.roughness,\n                    set: (value, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).clearCoat.roughness = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.roughness\"],\n                },\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"texture\"),\n                    },\n                },\n                clearcoatNormalTexture: {\n                    scale: {\n                        type: \"number\",\n                        get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.bumpTexture?.level,\n                        getTarget: GetMaterial,\n                        set: (value, material, index, payload) => (GetMaterial(material, index, payload).clearCoat.bumpTexture!.level = value),\n                    },\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"bumpTexture\"),\n                    },\n                },\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"textureRoughness\"),\n                    },\n                },\n            },\n            KHR_materials_dispersion: {\n                dispersion: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.dispersion,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.dispersion = value),\n                },\n            },\n            KHR_materials_emissive_strength: {\n                emissiveStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).emissiveIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).emissiveIntensity = value),\n                },\n            },\n            KHR_materials_ior: {\n                ior: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).indexOfRefraction = value),\n                },\n            },\n            KHR_materials_iridescence: {\n                iridescenceFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.intensity = value),\n                },\n                iridescenceIor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.indexOfRefraction = value),\n                },\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"texture\"),\n                    },\n                },\n                iridescenceThicknessMaximum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.maximumThickness = value),\n                },\n                iridescenceThicknessMinimum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.minimumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.minimumThickness = value),\n                },\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_sheen: {\n                sheenColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.color,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).sheen.color.copyFrom(value),\n                },\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"texture\"),\n                    },\n                },\n                sheenRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).sheen.intensity = value),\n                },\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_specular: {\n                specularFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicF0Factor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).metallicF0Factor = value),\n                    getPropertyName: [() => \"metallicF0Factor\"],\n                },\n                specularColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value),\n                    getPropertyName: [() => \"metallicReflectanceColor\"],\n                },\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"metallicReflectanceTexture\"),\n                    },\n                },\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"reflectanceTexture\"),\n                    },\n                },\n            },\n            KHR_materials_transmission: {\n                transmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.refractionIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.refractionIntensity = value),\n                    getPropertyName: [() => \"subSurface.refractionIntensity\"],\n                },\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"refractionIntensityTexture\"),\n                    },\n                },\n            },\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.translucencyIntensity = value),\n                },\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyIntensityTexture\"),\n                    },\n                },\n                diffuseTransmissionColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => value && GetMaterial(material, index, payload).subSurface.translucencyColor?.copyFrom(value),\n                },\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyColorTexture\"),\n                    },\n                },\n            },\n            KHR_materials_volume: {\n                attenuationColor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value),\n                },\n                attenuationDistance: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColorAtDistance,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value),\n                },\n                thicknessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.maximumThickness = value),\n                },\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"thicknessTexture\"),\n                    },\n                },\n            },\n        },\n    },\n};\n\nconst extensionsTree: IGLTFObjectModelTreeExtensionsObject = {\n    KHR_lights_punctual: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IKHRLightsPunctual_Light[]) => lights.length,\n                getTarget: (lights: IKHRLightsPunctual_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IKHRLightsPunctual_Light[]) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.diffuse,\n                    set: (value: Color3, light: IKHRLightsPunctual_Light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.intensity,\n                    set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"intensity\"],\n                },\n                range: {\n                    type: \"number\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.range,\n                    set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? (light._babylonLight.range = value) : undefined),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"range\"],\n                },\n                spot: {\n                    innerConeAngle: {\n                        type: \"number\",\n                        get: (light: IKHRLightsPunctual_Light) => (light._babylonLight as SpotLight)?.innerAngle,\n                        set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? ((light._babylonLight as SpotLight).innerAngle = value) : undefined),\n                        getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"innerConeAngle\"],\n                    },\n                    outerConeAngle: {\n                        type: \"number\",\n                        get: (light: IKHRLightsPunctual_Light) => (light._babylonLight as SpotLight)?.angle,\n                        set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? ((light._babylonLight as SpotLight).angle = value) : undefined),\n                        getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"outerConeAngle\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_ies: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IKHRLightsPunctual_Light[]) => lights.length,\n                getTarget: (lights: IKHRLightsPunctual_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IKHRLightsPunctual_Light[]) => \"length\"],\n            },\n        },\n    },\n    EXT_lights_image_based: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonTexture!),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonTexture?.level,\n                    set: (value, light) => {\n                        if (light._babylonTexture) {\n                            light._babylonTexture.level = value;\n                        }\n                    },\n\n                    getTarget: (light) => light._babylonTexture,\n                },\n                rotation: {\n                    type: \"Quaternion\",\n                    get: (light) => light._babylonTexture && Quaternion.FromRotationMatrix(light._babylonTexture?.getReflectionTextureMatrix()),\n                    set: (value, light) => {\n                        if (!light._babylonTexture) {\n                            return;\n                        }\n                        // Invert the rotation so that positive rotation is counter-clockwise.\n                        if (!light._babylonTexture.getScene()?.useRightHandedSystem) {\n                            value = Quaternion.Inverse(value);\n                        }\n\n                        Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n            },\n        },\n    },\n};\n\nfunction GetTexture(material: IMaterial, payload: any, textureType: keyof PBRMaterial, textureInObject?: string) {\n    const babylonMaterial = GetMaterial(material, payload);\n    return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];\n}\nfunction GetMaterial(material: IMaterial, _index?: number, payload?: any) {\n    return material._data?.[payload?.fillMode ?? Constants.MATERIAL_TriangleFillMode]?.babylonMaterial as PBRMaterial;\n}\nfunction GenerateTextureMap(textureType: keyof PBRMaterial, textureInObject?: string): ITextureDefinition {\n    return {\n        offset: {\n            componentsCount: 2,\n            // assuming two independent values for u and v, and NOT a Vector2\n            type: \"Vector2\",\n            get: (material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uOffset, texture?.vOffset);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uOffset = value.x), (texture.vOffset = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uOffset`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vOffset`,\n            ],\n        },\n        rotation: {\n            type: \"number\",\n            get: (material, _index?, payload?) => GetTexture(material, payload, textureType, textureInObject)?.wAng,\n            getTarget: GetMaterial,\n            set: (value, material, _index?, payload?) => (GetTexture(material, payload, textureType, textureInObject).wAng = value),\n            getPropertyName: [() => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.wAng`],\n        },\n        scale: {\n            componentsCount: 2,\n            type: \"Vector2\",\n            get: (material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uScale, texture?.vScale);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uScale = value.x), (texture.vScale = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uScale`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vScale`,\n            ],\n        },\n    };\n}\n\nconst objectModelMapping: IGLTFObjectModelTree = {\n    cameras: camerasTree,\n    nodes: nodesTree,\n    materials: materialsTree,\n    extensions: extensionsTree,\n    animations: animationsTree,\n    meshes: meshesTree,\n};\n\n/**\n * get a path-to-object converter for the given glTF tree\n * @param gltf the glTF tree to use\n * @returns a path-to-object converter for the given glTF tree\n */\nexport function GetPathToObjectConverter(gltf: IGLTF) {\n    return new GLTFPathToObjectConverter(gltf, objectModelMapping);\n}\n\n/**\n * This function will return the object accessor for the given key in the object model\n * If the key is not found, it will return undefined\n * @param key the key to get the mapping for, for example /materials/\\{\\}/emissiveFactor\n * @returns an object accessor for the given key, or undefined if the key is not found\n */\nexport function GetMappingForKey(key: string): IObjectAccessor | undefined {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that current is an object accessor\n    if (current && current.type && current.get) {\n        return current;\n    }\n    return undefined;\n}\n\n/**\n * Set interpolation for a specific key in the object model\n * @param key the key to set, for example /materials/\\{\\}/emissiveFactor\n * @param interpolation the interpolation elements array\n */\nexport function SetInterpolationForKey(key: string, interpolation?: IInterpolationPropertyInfo[]): void {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that the current object is an object accessor\n    if (current && current.type && current.get) {\n        (current as IObjectAccessor).interpolation = interpolation;\n    }\n}\n\n/**\n * This will ad a new object accessor in the object model at the given key.\n * Note that this will NOT change the typescript types. To do that you will need to change the interface itself (extending it in the module that uses it)\n * @param key the key to add the object accessor at. For example /cameras/\\{\\}/perspective/aspectRatio\n * @param accessor the object accessor to add\n */\nexport function AddObjectAccessorToKey<GLTFTargetType = any, BabylonTargetType = any, BabylonValueType = any>(\n    key: string,\n    accessor: IObjectAccessor<GLTFTargetType, BabylonTargetType, BabylonValueType>\n): void {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        if (!current[part]) {\n            if (part === \"?\") {\n                current.__ignoreObjectTree__ = true;\n                continue;\n            }\n            current[part] = {};\n            // if the part is __array__ then add the __target__ property\n            if (part === \"__array__\") {\n                current[part].__target__ = true;\n            }\n        }\n        current = current[part];\n    }\n    Object.assign(current, accessor);\n}\n", "import { Animation } from \"core/Animations/animation\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { INode } from \"./glTFLoaderInterfaces\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { SetInterpolationForKey } from \"./Extensions/objectModelMapping\";\r\n\r\n/** @internal */\r\nexport type GetValueFn = (target: any, source: Float32Array, offset: number, scale: number) => any;\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getVector3(_target: any, source: Float32Array, offset: number, scale: number): Vector3 {\r\n    return Vector3.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getQuaternion(_target: any, source: Float32Array, offset: number, scale: number): Quaternion {\r\n    return Quaternion.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getWeights(target: INode, source: Float32Array, offset: number, scale: number): Array<number> {\r\n    const value = new Array<number>(target._numMorphTargets!);\r\n    for (let i = 0; i < value.length; i++) {\r\n        value[i] = source[offset++] * scale;\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/** @internal */\r\nexport abstract class AnimationPropertyInfo {\r\n    /** @internal */\r\n    public constructor(\r\n        public readonly type: number,\r\n        public readonly name: string,\r\n        public readonly getValue: GetValueFn,\r\n        public readonly getStride: (target: any) => number\r\n    ) {}\r\n\r\n    protected _buildAnimation(name: string, fps: number, keys: any[]): Animation {\r\n        const babylonAnimation = new Animation(name, this.name, fps, this.type);\r\n        babylonAnimation.setKeys(keys);\r\n        return babylonAnimation;\r\n    }\r\n\r\n    /** @internal */\r\n    public abstract buildAnimations(target: any, name: string, fps: number, keys: any[]): { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[];\r\n}\r\n\r\n/** @internal */\r\nexport class TransformNodeAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        babylonAnimations.push({ babylonAnimatable: target._babylonTransformNode!, babylonAnimation: this._buildAnimation(name, fps, keys) });\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WeightAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        if (target._numMorphTargets) {\r\n            for (let targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {\r\n                const babylonAnimation = new Animation(`${name}_${targetIndex}`, this.name, fps, this.type);\r\n                babylonAnimation.setKeys(\r\n                    keys.map((key) => ({\r\n                        frame: key.frame,\r\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\r\n                        value: key.value[targetIndex],\r\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,\r\n                        interpolation: key.interpolation,\r\n                    }))\r\n                );\r\n\r\n                if (target._primitiveBabylonMeshes) {\r\n                    for (const babylonMesh of target._primitiveBabylonMeshes) {\r\n                        if (babylonMesh.morphTargetManager) {\r\n                            const morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\r\n                            const babylonAnimationClone = babylonAnimation.clone();\r\n                            morphTarget.animations.push(babylonAnimationClone);\r\n                            babylonAnimations.push({ babylonAnimatable: morphTarget, babylonAnimation: babylonAnimationClone });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\nSetInterpolationForKey(\"/nodes/{}/translation\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"position\", getVector3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/rotation\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_QUATERNION, \"rotationQuaternion\", getQuaternion, () => 4)]);\r\nSetInterpolationForKey(\"/nodes/{}/scale\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"scaling\", getVector3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/weights\", [new WeightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"influence\", getWeights, (target) => target._numMorphTargets!)]);\r\n"],
  "mappings": "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",
  "names": []
}

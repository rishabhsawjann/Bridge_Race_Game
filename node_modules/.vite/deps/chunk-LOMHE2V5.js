import {
  Node
} from "./chunk-FVZEVIG4.js";
import {
  Axis,
  LightConstants
} from "./chunk-ZXZ7GVGK.js";
import {
  SerializationHelper
} from "./chunk-ZFNWT3XJ.js";
import {
  __decorate,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsVector3
} from "./chunk-GV3J66OA.js";
import {
  Color3,
  TmpColors
} from "./chunk-4SAYSEWY.js";
import {
  Matrix,
  TmpVectors,
  Vector3
} from "./chunk-77BXJTWI.js";
import {
  Tools
} from "./chunk-MDBWUNVA.js";
import {
  GetClass
} from "./chunk-MIVJKRRS.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/Materials/uniformBuffer.js
var UniformBuffer = class _UniformBuffer {
  /**
   * Instantiates a new Uniform buffer objects.
   *
   * Handles blocks of uniform on the GPU.
   *
   * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.
   *
   * For more information, please refer to :
   * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
   * @param engine Define the engine the buffer is associated with
   * @param data Define the data contained in the buffer
   * @param dynamic Define if the buffer is updatable
   * @param name to assign to the buffer (debugging purpose)
   * @param forceNoUniformBuffer define that this object must not rely on UBO objects
   * @param trackUBOsInFrame define if the UBOs should be tracked in the frame (default: undefined - will use the value from Engine._features.trackUbosInFrame)
   */
  constructor(engine, data, dynamic = false, name, forceNoUniformBuffer = false, trackUBOsInFrame) {
    this._uniformNames = [];
    this._valueCache = {};
    this._engine = engine;
    this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;
    this._dynamic = dynamic;
    this._name = name ?? "no-name";
    this._data = data || [];
    this._uniformLocations = {};
    this._uniformSizes = {};
    this._uniformArraySizes = {};
    this._uniformLocationPointer = 0;
    this._needSync = false;
    this._trackUBOsInFrame = false;
    if (trackUBOsInFrame === void 0 && this._engine._features.trackUbosInFrame || trackUBOsInFrame === true) {
      this._buffers = [];
      this._bufferIndex = -1;
      this._createBufferOnWrite = false;
      this._currentFrameId = 0;
      this._trackUBOsInFrame = true;
    }
    if (this._noUBO) {
      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;
      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;
      this.updateFloat = this._updateFloatForEffect;
      this.updateFloat2 = this._updateFloat2ForEffect;
      this.updateFloat3 = this._updateFloat3ForEffect;
      this.updateFloat4 = this._updateFloat4ForEffect;
      this.updateFloatArray = this._updateFloatArrayForEffect;
      this.updateArray = this._updateArrayForEffect;
      this.updateIntArray = this._updateIntArrayForEffect;
      this.updateUIntArray = this._updateUIntArrayForEffect;
      this.updateMatrix = this._updateMatrixForEffect;
      this.updateMatrices = this._updateMatricesForEffect;
      this.updateVector3 = this._updateVector3ForEffect;
      this.updateVector4 = this._updateVector4ForEffect;
      this.updateColor3 = this._updateColor3ForEffect;
      this.updateColor4 = this._updateColor4ForEffect;
      this.updateDirectColor4 = this._updateDirectColor4ForEffect;
      this.updateInt = this._updateIntForEffect;
      this.updateInt2 = this._updateInt2ForEffect;
      this.updateInt3 = this._updateInt3ForEffect;
      this.updateInt4 = this._updateInt4ForEffect;
      this.updateUInt = this._updateUIntForEffect;
      this.updateUInt2 = this._updateUInt2ForEffect;
      this.updateUInt3 = this._updateUInt3ForEffect;
      this.updateUInt4 = this._updateUInt4ForEffect;
    } else {
      this._engine._uniformBuffers.push(this);
      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;
      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;
      this.updateFloat = this._updateFloatForUniform;
      this.updateFloat2 = this._updateFloat2ForUniform;
      this.updateFloat3 = this._updateFloat3ForUniform;
      this.updateFloat4 = this._updateFloat4ForUniform;
      this.updateFloatArray = this._updateFloatArrayForUniform;
      this.updateArray = this._updateArrayForUniform;
      this.updateIntArray = this._updateIntArrayForUniform;
      this.updateUIntArray = this._updateUIntArrayForUniform;
      this.updateMatrix = this._updateMatrixForUniform;
      this.updateMatrices = this._updateMatricesForUniform;
      this.updateVector3 = this._updateVector3ForUniform;
      this.updateVector4 = this._updateVector4ForUniform;
      this.updateColor3 = this._updateColor3ForUniform;
      this.updateColor4 = this._updateColor4ForUniform;
      this.updateDirectColor4 = this._updateDirectColor4ForUniform;
      this.updateInt = this._updateIntForUniform;
      this.updateInt2 = this._updateInt2ForUniform;
      this.updateInt3 = this._updateInt3ForUniform;
      this.updateInt4 = this._updateInt4ForUniform;
      this.updateUInt = this._updateUIntForUniform;
      this.updateUInt2 = this._updateUInt2ForUniform;
      this.updateUInt3 = this._updateUInt3ForUniform;
      this.updateUInt4 = this._updateUInt4ForUniform;
    }
  }
  /**
   * Indicates if the buffer is using the WebGL2 UBO implementation,
   * or just falling back on setUniformXXX calls.
   */
  get useUbo() {
    return !this._noUBO;
  }
  /**
   * Indicates if the WebGL underlying uniform buffer is in sync
   * with the javascript cache data.
   */
  get isSync() {
    return !this._needSync;
  }
  /**
   * Indicates if the WebGL underlying uniform buffer is dynamic.
   * Also, a dynamic UniformBuffer will disable cache verification and always
   * update the underlying WebGL uniform buffer to the GPU.
   * @returns if Dynamic, otherwise false
   */
  isDynamic() {
    return this._dynamic;
  }
  /**
   * The data cache on JS side.
   * @returns the underlying data as a float array
   */
  getData() {
    return this._bufferData;
  }
  /**
   * The underlying WebGL Uniform buffer.
   * @returns the webgl buffer
   */
  getBuffer() {
    return this._buffer;
  }
  /**
   * The names of the uniforms in the buffer.
   * @returns an array of uniform names
   */
  getUniformNames() {
    return this._uniformNames;
  }
  /**
   * std140 layout specifies how to align data within an UBO structure.
   * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159
   * for specs.
   * @param size
   */
  _fillAlignment(size) {
    let alignment;
    if (size <= 2) {
      alignment = size;
    } else {
      alignment = 4;
    }
    if (this._uniformLocationPointer % alignment !== 0) {
      const oldPointer = this._uniformLocationPointer;
      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;
      const diff = this._uniformLocationPointer - oldPointer;
      for (let i = 0; i < diff; i++) {
        this._data.push(0);
      }
    }
  }
  /**
   * Adds an uniform in the buffer.
   * Warning : the subsequents calls of this function must be in the same order as declared in the shader
   * for the layout to be correct ! The addUniform function only handles types like float, vec2, vec3, vec4, mat4,
   * meaning size=1,2,3,4 or 16. It does not handle struct types.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param size Data size, or data directly.
   * @param arraySize The number of elements in the array, 0 if not an array.
   */
  addUniform(name, size, arraySize = 0) {
    if (arraySize > 0 && typeof size === "number") {
      this._uniformArraySizes[name] = { strideSize: size, arraySize };
    }
    if (this._uniformLocations[name] !== void 0) {
      return;
    }
    this._uniformNames.push(name);
    if (this._noUBO) {
      return;
    }
    let data;
    if (arraySize > 0) {
      if (size instanceof Array) {
        throw "addUniform should not be use with Array in UBO: " + name;
      }
      this._fillAlignment(4);
      if (size == 16) {
        size = size * arraySize;
      } else {
        const perElementPadding = 4 - size;
        const totalPadding = perElementPadding * arraySize;
        size = size * arraySize + totalPadding;
      }
      data = [];
      for (let i = 0; i < size; i++) {
        data.push(0);
      }
    } else {
      if (size instanceof Array) {
        data = size;
        size = data.length;
      } else {
        data = [];
        for (let i = 0; i < size; i++) {
          data.push(0);
        }
      }
      this._fillAlignment(size);
    }
    this._uniformSizes[name] = size;
    this._uniformLocations[name] = this._uniformLocationPointer;
    this._uniformLocationPointer += size;
    for (let i = 0; i < size; i++) {
      this._data.push(data[i]);
    }
    this._needSync = true;
  }
  /**
   * Adds a Matrix 4x4 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param mat A 4x4 matrix.
   */
  addMatrix(name, mat) {
    this.addUniform(name, Array.prototype.slice.call(mat.asArray()));
  }
  /**
   * Adds a vec2 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param x Define the x component value of the vec2
   * @param y Define the y component value of the vec2
   */
  addFloat2(name, x, y) {
    const temp = [x, y];
    this.addUniform(name, temp);
  }
  /**
   * Adds a vec3 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param x Define the x component value of the vec3
   * @param y Define the y component value of the vec3
   * @param z Define the z component value of the vec3
   */
  addFloat3(name, x, y, z) {
    const temp = [x, y, z];
    this.addUniform(name, temp);
  }
  /**
   * Adds a vec3 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param color Define the vec3 from a Color
   */
  addColor3(name, color) {
    const temp = [color.r, color.g, color.b];
    this.addUniform(name, temp);
  }
  /**
   * Adds a vec4 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param color Define the rgb components from a Color
   * @param alpha Define the a component of the vec4
   */
  addColor4(name, color, alpha) {
    const temp = [color.r, color.g, color.b, alpha];
    this.addUniform(name, temp);
  }
  /**
   * Adds a vec3 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param vector Define the vec3 components from a Vector
   */
  addVector3(name, vector) {
    const temp = [vector.x, vector.y, vector.z];
    this.addUniform(name, temp);
  }
  /**
   * Adds a Matrix 3x3 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   */
  addMatrix3x3(name) {
    this.addUniform(name, 12);
  }
  /**
   * Adds a Matrix 2x2 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   */
  addMatrix2x2(name) {
    this.addUniform(name, 8);
  }
  /**
   * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.
   */
  create() {
    if (this._noUBO) {
      return;
    }
    if (this._buffer) {
      return;
    }
    this._fillAlignment(4);
    this._bufferData = new Float32Array(this._data);
    this._rebuild();
    this._needSync = true;
  }
  // The result of this method is used for debugging purpose, as part of the buffer name
  // It is meant to more easily know what this buffer is about when debugging
  // Some buffers can have a lot of uniforms (several dozens), so the method only returns the first 10 of them
  // (should be enough to understand what the buffer is for)
  _getNamesDebug() {
    const names = [];
    let i = 0;
    for (const name in this._uniformLocations) {
      names.push(name);
      if (++i === 10) {
        break;
      }
    }
    return names.join(",");
  }
  /** @internal */
  _rebuild() {
    if (this._noUBO || !this._bufferData) {
      return;
    }
    if (this._dynamic) {
      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + "_UniformList:" + this._getNamesDebug());
    } else {
      this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + "_UniformList:" + this._getNamesDebug());
    }
    if (this._trackUBOsInFrame) {
      this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]);
      this._bufferIndex = this._buffers.length - 1;
      this._createBufferOnWrite = false;
    }
  }
  /** @internal */
  _rebuildAfterContextLost() {
    if (this._trackUBOsInFrame) {
      this._buffers = [];
      this._currentFrameId = 0;
    }
    this._rebuild();
  }
  /** @internal */
  get _numBuffers() {
    return this._buffers.length;
  }
  /** @internal */
  get _indexBuffer() {
    return this._bufferIndex;
  }
  /** Gets or sets the name of this buffer */
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  /** Gets the current effect */
  get currentEffect() {
    return this._currentEffect;
  }
  _buffersEqual(buf1, buf2) {
    for (let i = 0; i < buf1.length; ++i) {
      if (buf1[i] !== buf2[i]) {
        return false;
      }
    }
    return true;
  }
  _copyBuffer(src, dst) {
    for (let i = 0; i < src.length; ++i) {
      dst[i] = src[i];
    }
  }
  /**
   * Updates the WebGL Uniform Buffer on the GPU.
   * If the `dynamic` flag is set to true, no cache comparison is done.
   * Otherwise, the buffer will be updated only if the cache differs.
   */
  update() {
    if (this._noUBO) {
      return;
    }
    this.bindUniformBuffer();
    if (!this._buffer) {
      this.create();
      return;
    }
    if (!this._dynamic && !this._needSync) {
      this._createBufferOnWrite = this._trackUBOsInFrame;
      return;
    }
    if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {
      if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {
        this._needSync = false;
        this._createBufferOnWrite = this._trackUBOsInFrame;
        return;
      } else {
        this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);
      }
    }
    this._engine.updateUniformBuffer(this._buffer, this._bufferData);
    if (this._engine._features._collectUbosUpdatedInFrame) {
      if (!_UniformBuffer._UpdatedUbosInFrame[this._name]) {
        _UniformBuffer._UpdatedUbosInFrame[this._name] = 0;
      }
      _UniformBuffer._UpdatedUbosInFrame[this._name]++;
    }
    this._needSync = false;
    this._createBufferOnWrite = this._trackUBOsInFrame;
  }
  _createNewBuffer() {
    if (this._bufferIndex + 1 < this._buffers.length) {
      this._bufferIndex++;
      this._buffer = this._buffers[this._bufferIndex][0];
      this._createBufferOnWrite = false;
      this._needSync = true;
    } else {
      this._rebuild();
    }
  }
  _checkNewFrame() {
    if (this._trackUBOsInFrame && this._currentFrameId !== this._engine.frameId) {
      this._currentFrameId = this._engine.frameId;
      this._createBufferOnWrite = false;
      if (this._buffers && this._buffers.length > 0) {
        this._needSync = this._bufferIndex !== 0;
        this._bufferIndex = 0;
        this._buffer = this._buffers[this._bufferIndex][0];
      } else {
        this._bufferIndex = -1;
      }
    }
  }
  /**
   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.
   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.
   * @param data Define the flattened data
   * @param size Define the size of the data.
   */
  updateUniform(uniformName, data, size) {
    this._checkNewFrame();
    let location = this._uniformLocations[uniformName];
    if (location === void 0) {
      if (this._buffer) {
        Logger.Error("Cannot add an uniform after UBO has been created. uniformName=" + uniformName);
        return;
      }
      this.addUniform(uniformName, size);
      location = this._uniformLocations[uniformName];
    }
    if (!this._buffer) {
      this.create();
    }
    if (!this._dynamic) {
      let changed = false;
      for (let i = 0; i < size; i++) {
        if (size === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[location + i] !== Math.fround(data[i])) {
          changed = true;
          if (this._createBufferOnWrite) {
            this._createNewBuffer();
          }
          this._bufferData[location + i] = data[i];
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (let i = 0; i < size; i++) {
        this._bufferData[location + i] = data[i];
      }
    }
  }
  /**
   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.
   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.
   * @param data Define the flattened data
   * @param size Define the size of the data.
   */
  updateUniformArray(uniformName, data, size) {
    this._checkNewFrame();
    const location = this._uniformLocations[uniformName];
    if (location === void 0) {
      Logger.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");
      return;
    }
    if (!this._buffer) {
      this.create();
    }
    const arraySizes = this._uniformArraySizes[uniformName];
    if (!this._dynamic) {
      let changed = false;
      let countToFour = 0;
      let baseStride = 0;
      for (let i = 0; i < size; i++) {
        if (this._bufferData[location + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {
          changed = true;
          if (this._createBufferOnWrite) {
            this._createNewBuffer();
          }
          this._bufferData[location + baseStride * 4 + countToFour] = data[i];
        }
        countToFour++;
        if (countToFour === arraySizes.strideSize) {
          for (; countToFour < 4; countToFour++) {
            this._bufferData[location + baseStride * 4 + countToFour] = 0;
          }
          countToFour = 0;
          baseStride++;
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (let i = 0; i < size; i++) {
        this._bufferData[location + i] = data[i];
      }
    }
  }
  _cacheMatrix(name, matrix) {
    this._checkNewFrame();
    const cache = this._valueCache[name];
    const flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[name] = flag;
    return true;
  }
  // Update methods
  _updateMatrix3x3ForUniform(name, matrix) {
    for (let i = 0; i < 3; i++) {
      _UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];
      _UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];
      _UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];
      _UniformBuffer._TempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name, _UniformBuffer._TempBuffer, 12);
  }
  _updateMatrix3x3ForEffect(name, matrix) {
    this._currentEffect.setMatrix3x3(name, matrix);
  }
  _updateMatrix2x2ForEffect(name, matrix) {
    this._currentEffect.setMatrix2x2(name, matrix);
  }
  _updateMatrix2x2ForUniform(name, matrix) {
    for (let i = 0; i < 2; i++) {
      _UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];
      _UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];
      _UniformBuffer._TempBuffer[i * 4 + 2] = 0;
      _UniformBuffer._TempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name, _UniformBuffer._TempBuffer, 8);
  }
  _updateFloatForEffect(name, x, suffix = "") {
    this._currentEffect.setFloat(name + suffix, x);
  }
  _updateFloatForUniform(name, x) {
    _UniformBuffer._TempBuffer[0] = x;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 1);
  }
  _updateFloat2ForEffect(name, x, y, suffix = "") {
    this._currentEffect.setFloat2(name + suffix, x, y);
  }
  _updateFloat2ForUniform(name, x, y) {
    _UniformBuffer._TempBuffer[0] = x;
    _UniformBuffer._TempBuffer[1] = y;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 2);
  }
  _updateFloat3ForEffect(name, x, y, z, suffix = "") {
    this._currentEffect.setFloat3(name + suffix, x, y, z);
  }
  _updateFloat3ForUniform(name, x, y, z) {
    _UniformBuffer._TempBuffer[0] = x;
    _UniformBuffer._TempBuffer[1] = y;
    _UniformBuffer._TempBuffer[2] = z;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 3);
  }
  _updateFloat4ForEffect(name, x, y, z, w, suffix = "") {
    this._currentEffect.setFloat4(name + suffix, x, y, z, w);
  }
  _updateFloat4ForUniform(name, x, y, z, w) {
    _UniformBuffer._TempBuffer[0] = x;
    _UniformBuffer._TempBuffer[1] = y;
    _UniformBuffer._TempBuffer[2] = z;
    _UniformBuffer._TempBuffer[3] = w;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  _updateFloatArrayForEffect(name, array, suffix = "") {
    switch (this._uniformArraySizes[name]?.strideSize) {
      case 2:
        this._currentEffect.setFloatArray2(name + suffix, array);
        break;
      case 3:
        this._currentEffect.setFloatArray3(name + suffix, array);
        break;
      case 4:
        this._currentEffect.setFloatArray4(name + suffix, array);
        break;
      default:
        this._currentEffect.setFloatArray(name + suffix, array);
        break;
    }
  }
  _updateFloatArrayForUniform(name, array) {
    this.updateUniformArray(name, array, array.length);
  }
  _updateArrayForEffect(name, array) {
    this._currentEffect.setArray(name, array);
  }
  _updateArrayForUniform(name, array) {
    this.updateUniformArray(name, array, array.length);
  }
  _updateIntArrayForEffect(name, array) {
    this._currentEffect.setIntArray(name, array);
  }
  _updateIntArrayForUniform(name, array) {
    _UniformBuffer._TempBufferInt32View.set(array);
    this.updateUniformArray(name, _UniformBuffer._TempBuffer, array.length);
  }
  _updateUIntArrayForEffect(name, array) {
    this._currentEffect.setUIntArray(name, array);
  }
  _updateUIntArrayForUniform(name, array) {
    _UniformBuffer._TempBufferUInt32View.set(array);
    this.updateUniformArray(name, _UniformBuffer._TempBuffer, array.length);
  }
  _updateMatrixForEffect(name, mat) {
    this._currentEffect.setMatrix(name, mat);
  }
  _updateMatrixForUniform(name, mat) {
    if (this._cacheMatrix(name, mat)) {
      this.updateUniform(name, mat.asArray(), 16);
    }
  }
  _updateMatricesForEffect(name, mat) {
    this._currentEffect.setMatrices(name, mat);
  }
  _updateMatricesForUniform(name, mat) {
    this.updateUniform(name, mat, mat.length);
  }
  _updateVector3ForEffect(name, vector) {
    this._currentEffect.setVector3(name, vector);
  }
  _updateVector3ForUniform(name, vector) {
    _UniformBuffer._TempBuffer[0] = vector.x;
    _UniformBuffer._TempBuffer[1] = vector.y;
    _UniformBuffer._TempBuffer[2] = vector.z;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 3);
  }
  _updateVector4ForEffect(name, vector) {
    this._currentEffect.setVector4(name, vector);
  }
  _updateVector4ForUniform(name, vector) {
    _UniformBuffer._TempBuffer[0] = vector.x;
    _UniformBuffer._TempBuffer[1] = vector.y;
    _UniformBuffer._TempBuffer[2] = vector.z;
    _UniformBuffer._TempBuffer[3] = vector.w;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  _updateColor3ForEffect(name, color, suffix = "") {
    this._currentEffect.setColor3(name + suffix, color);
  }
  _updateColor3ForUniform(name, color) {
    _UniformBuffer._TempBuffer[0] = color.r;
    _UniformBuffer._TempBuffer[1] = color.g;
    _UniformBuffer._TempBuffer[2] = color.b;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 3);
  }
  _updateColor4ForEffect(name, color, alpha, suffix = "") {
    this._currentEffect.setColor4(name + suffix, color, alpha);
  }
  _updateDirectColor4ForEffect(name, color, suffix = "") {
    this._currentEffect.setDirectColor4(name + suffix, color);
  }
  _updateColor4ForUniform(name, color, alpha) {
    _UniformBuffer._TempBuffer[0] = color.r;
    _UniformBuffer._TempBuffer[1] = color.g;
    _UniformBuffer._TempBuffer[2] = color.b;
    _UniformBuffer._TempBuffer[3] = alpha;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  _updateDirectColor4ForUniform(name, color) {
    _UniformBuffer._TempBuffer[0] = color.r;
    _UniformBuffer._TempBuffer[1] = color.g;
    _UniformBuffer._TempBuffer[2] = color.b;
    _UniformBuffer._TempBuffer[3] = color.a;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  _updateIntForEffect(name, x, suffix = "") {
    this._currentEffect.setInt(name + suffix, x);
  }
  _updateIntForUniform(name, x) {
    _UniformBuffer._TempBufferInt32View[0] = x;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 1);
  }
  _updateInt2ForEffect(name, x, y, suffix = "") {
    this._currentEffect.setInt2(name + suffix, x, y);
  }
  _updateInt2ForUniform(name, x, y) {
    _UniformBuffer._TempBufferInt32View[0] = x;
    _UniformBuffer._TempBufferInt32View[1] = y;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 2);
  }
  _updateInt3ForEffect(name, x, y, z, suffix = "") {
    this._currentEffect.setInt3(name + suffix, x, y, z);
  }
  _updateInt3ForUniform(name, x, y, z) {
    _UniformBuffer._TempBufferInt32View[0] = x;
    _UniformBuffer._TempBufferInt32View[1] = y;
    _UniformBuffer._TempBufferInt32View[2] = z;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 3);
  }
  _updateInt4ForEffect(name, x, y, z, w, suffix = "") {
    this._currentEffect.setInt4(name + suffix, x, y, z, w);
  }
  _updateInt4ForUniform(name, x, y, z, w) {
    _UniformBuffer._TempBufferInt32View[0] = x;
    _UniformBuffer._TempBufferInt32View[1] = y;
    _UniformBuffer._TempBufferInt32View[2] = z;
    _UniformBuffer._TempBufferInt32View[3] = w;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  _updateUIntForEffect(name, x, suffix = "") {
    this._currentEffect.setUInt(name + suffix, x);
  }
  _updateUIntForUniform(name, x) {
    _UniformBuffer._TempBufferUInt32View[0] = x;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 1);
  }
  _updateUInt2ForEffect(name, x, y, suffix = "") {
    this._currentEffect.setUInt2(name + suffix, x, y);
  }
  _updateUInt2ForUniform(name, x, y) {
    _UniformBuffer._TempBufferUInt32View[0] = x;
    _UniformBuffer._TempBufferUInt32View[1] = y;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 2);
  }
  _updateUInt3ForEffect(name, x, y, z, suffix = "") {
    this._currentEffect.setUInt3(name + suffix, x, y, z);
  }
  _updateUInt3ForUniform(name, x, y, z) {
    _UniformBuffer._TempBufferUInt32View[0] = x;
    _UniformBuffer._TempBufferUInt32View[1] = y;
    _UniformBuffer._TempBufferUInt32View[2] = z;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 3);
  }
  _updateUInt4ForEffect(name, x, y, z, w, suffix = "") {
    this._currentEffect.setUInt4(name + suffix, x, y, z, w);
  }
  _updateUInt4ForUniform(name, x, y, z, w) {
    _UniformBuffer._TempBufferUInt32View[0] = x;
    _UniformBuffer._TempBufferUInt32View[1] = y;
    _UniformBuffer._TempBufferUInt32View[2] = z;
    _UniformBuffer._TempBufferUInt32View[3] = w;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  /**
   * Sets a sampler uniform on the effect.
   * @param name Define the name of the sampler.
   * @param texture Define the texture to set in the sampler
   */
  setTexture(name, texture) {
    this._currentEffect.setTexture(name, texture);
  }
  /**
   * Sets an array of sampler uniforms on the effect.
   * @param name Define the name of uniform.
   * @param textures Define the textures to set in the array of samplers
   */
  setTextureArray(name, textures) {
    this._currentEffect.setTextureArray(name, textures);
  }
  /**
   * Sets a sampler uniform on the effect.
   * @param name Define the name of the sampler.
   * @param texture Define the (internal) texture to set in the sampler
   */
  bindTexture(name, texture) {
    this._currentEffect._bindTexture(name, texture);
  }
  /**
   * Directly updates the value of the uniform in the cache AND on the GPU.
   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.
   * @param data Define the flattened data
   */
  updateUniformDirectly(uniformName, data) {
    this.updateUniform(uniformName, data, data.length);
    this.update();
  }
  /**
   * Associates an effect to this uniform buffer
   * @param effect Define the effect to associate the buffer to
   * @param name Name of the uniform block in the shader.
   */
  bindToEffect(effect, name) {
    this._currentEffect = effect;
    this._currentEffectName = name;
  }
  /**
   * Binds the current (GPU) buffer to the effect
   */
  bindUniformBuffer() {
    if (!this._noUBO && this._buffer && this._currentEffect) {
      this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);
    }
  }
  /**
   * Dissociates the current effect from this uniform buffer
   */
  unbindEffect() {
    this._currentEffect = void 0;
    this._currentEffectName = void 0;
  }
  /**
   * Sets the current state of the class (_bufferIndex, _buffer) to point to the data buffer passed in parameter if this buffer is one of the buffers handled by the class (meaning if it can be found in the _buffers array)
   * This method is meant to be able to update a buffer at any time: just call setDataBuffer to set the class in the right state, call some updateXXX methods and then call udpate() => that will update the GPU buffer on the graphic card
   * @param dataBuffer buffer to look for
   * @returns true if the buffer has been found and the class internal state points to it, else false
   */
  setDataBuffer(dataBuffer) {
    if (!this._buffers) {
      return this._buffer === dataBuffer;
    }
    for (let b = 0; b < this._buffers.length; ++b) {
      const buffer = this._buffers[b];
      if (buffer[0] === dataBuffer) {
        this._bufferIndex = b;
        this._buffer = dataBuffer;
        this._createBufferOnWrite = false;
        this._currentEffect = void 0;
        if (this._buffers.length > 1 && this._buffers[b][1]) {
          this._bufferData.set(this._buffers[b][1]);
        }
        this._valueCache = {};
        this._currentFrameId = this._engine.frameId;
        return true;
      }
    }
    return false;
  }
  /**
   * Checks if the uniform buffer has a uniform with the given name.
   * @param name Name of the uniform to check
   * @returns True if the uniform exists, false otherwise.
   */
  has(name) {
    return this._uniformLocations[name] !== void 0;
  }
  /**
   * Disposes the uniform buffer.
   */
  dispose() {
    if (this._noUBO) {
      return;
    }
    const uniformBuffers = this._engine._uniformBuffers;
    const index = uniformBuffers.indexOf(this);
    if (index !== -1) {
      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];
      uniformBuffers.pop();
    }
    if (this._trackUBOsInFrame && this._buffers) {
      for (let i = 0; i < this._buffers.length; ++i) {
        const buffer = this._buffers[i][0];
        this._engine._releaseBuffer(buffer);
      }
    } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {
      this._buffer = null;
    }
  }
};
UniformBuffer._UpdatedUbosInFrame = {};
UniformBuffer._MAX_UNIFORM_SIZE = 256;
UniformBuffer._TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);
UniformBuffer._TempBufferInt32View = new Int32Array(UniformBuffer._TempBuffer.buffer);
UniformBuffer._TempBufferUInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);

// node_modules/@babylonjs/core/Lights/light.js
var Light = class _Light extends Node {
  /**
   * Defines how far from the source the light is impacting in scene units.
   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
   */
  get range() {
    return this._range;
  }
  /**
   * Defines how far from the source the light is impacting in scene units.
   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
   */
  set range(value) {
    this._range = value;
    this._inverseSquaredRange = 1 / (this.range * this.range);
  }
  /**
   * Gets the photometric scale used to interpret the intensity.
   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
   */
  get intensityMode() {
    return this._intensityMode;
  }
  /**
   * Sets the photometric scale used to interpret the intensity.
   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
   */
  set intensityMode(value) {
    this._intensityMode = value;
    this._computePhotometricScale();
  }
  /**
   * Gets the light radius used by PBR Materials to simulate soft area lights.
   */
  get radius() {
    return this._radius;
  }
  /**
   * sets the light radius used by PBR Materials to simulate soft area lights.
   */
  set radius(value) {
    this._radius = value;
    this._computePhotometricScale();
  }
  /**
   * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
   * the current shadow generator.
   */
  get shadowEnabled() {
    return this._shadowEnabled;
  }
  /**
   * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
   * the current shadow generator.
   */
  set shadowEnabled(value) {
    if (this._shadowEnabled === value) {
      return;
    }
    this._shadowEnabled = value;
    this._markMeshesAsLightDirty();
  }
  /**
   * Gets the only meshes impacted by this light.
   */
  get includedOnlyMeshes() {
    return this._includedOnlyMeshes;
  }
  /**
   * Sets the only meshes impacted by this light.
   */
  set includedOnlyMeshes(value) {
    this._includedOnlyMeshes = value;
    this._hookArrayForIncludedOnly(value);
  }
  /**
   * Gets the meshes not impacted by this light.
   */
  get excludedMeshes() {
    return this._excludedMeshes;
  }
  /**
   * Sets the meshes not impacted by this light.
   */
  set excludedMeshes(value) {
    this._excludedMeshes = value;
    this._hookArrayForExcluded(value);
  }
  /**
   * Gets the layer id use to find what meshes are not impacted by the light.
   * Inactive if 0
   */
  get excludeWithLayerMask() {
    return this._excludeWithLayerMask;
  }
  /**
   * Sets the layer id use to find what meshes are not impacted by the light.
   * Inactive if 0
   */
  set excludeWithLayerMask(value) {
    this._excludeWithLayerMask = value;
    this._resyncMeshes();
  }
  /**
   * Gets the layer id use to find what meshes are impacted by the light.
   * Inactive if 0
   */
  get includeOnlyWithLayerMask() {
    return this._includeOnlyWithLayerMask;
  }
  /**
   * Sets the layer id use to find what meshes are impacted by the light.
   * Inactive if 0
   */
  set includeOnlyWithLayerMask(value) {
    this._includeOnlyWithLayerMask = value;
    this._resyncMeshes();
  }
  /**
   * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
   */
  get lightmapMode() {
    return this._lightmapMode;
  }
  /**
   * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
   */
  set lightmapMode(value) {
    if (this._lightmapMode === value) {
      return;
    }
    this._lightmapMode = value;
    this._markMeshesAsLightDirty();
  }
  /**
   * Returns the view matrix.
   * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.
   * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getViewMatrix(_faceIndex) {
    return null;
  }
  /**
   * Returns the projection matrix.
   * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).
   * @param _viewMatrix The view transform matrix of the light (optional).
   * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).
   * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getProjectionMatrix(_viewMatrix, _renderList) {
    return null;
  }
  /**
   * Creates a Light object in the scene.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The friendly name of the light
   * @param scene The scene the light belongs too
   */
  constructor(name, scene) {
    super(name, scene, false);
    this.diffuse = new Color3(1, 1, 1);
    this.specular = new Color3(1, 1, 1);
    this.falloffType = _Light.FALLOFF_DEFAULT;
    this.intensity = 1;
    this._range = Number.MAX_VALUE;
    this._inverseSquaredRange = 0;
    this._photometricScale = 1;
    this._intensityMode = _Light.INTENSITYMODE_AUTOMATIC;
    this._radius = 1e-5;
    this.renderPriority = 0;
    this._shadowEnabled = true;
    this._excludeWithLayerMask = 0;
    this._includeOnlyWithLayerMask = 0;
    this._lightmapMode = 0;
    this._shadowGenerators = null;
    this._excludedMeshesIds = new Array();
    this._includedOnlyMeshesIds = new Array();
    this._currentViewDepth = 0;
    this._isLight = true;
    this.getScene().addLight(this);
    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name);
    this._buildUniformLayout();
    this.includedOnlyMeshes = [];
    this.excludedMeshes = [];
    this._resyncMeshes();
  }
  /**
   * Sets the passed Effect "effect" with the Light textures.
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The light
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  transferTexturesToEffect(effect, lightIndex) {
    return this;
  }
  /**
   * Binds the lights information from the scene to the effect for the given mesh.
   * @param lightIndex Light index
   * @param scene The scene where the light belongs to
   * @param effect The effect we are binding the data to
   * @param useSpecular Defines if specular is supported
   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows
   */
  _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {
    const iAsString = lightIndex.toString();
    let needUpdate = false;
    this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {
      this._renderId = scene.getRenderId();
      this._lastUseSpecular = useSpecular;
      const scaledIntensity = this.getScaledIntensity();
      this.transferToEffect(effect, iAsString);
      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
      this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
      if (useSpecular) {
        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
        this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
      }
      needUpdate = true;
    }
    this.transferTexturesToEffect(effect, iAsString);
    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {
      const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();
      if (shadowGenerator) {
        shadowGenerator.bindShadowLight(iAsString, effect);
        needUpdate = true;
      }
    }
    if (needUpdate) {
      this._uniformBuffer.update();
    } else {
      this._uniformBuffer.bindUniformBuffer();
    }
  }
  /**
   * Returns the string "Light".
   * @returns the class name
   */
  getClassName() {
    return "Light";
  }
  /**
   * Converts the light information to a readable string for debug purpose.
   * @param fullDetails Supports for multiple levels of logging within scene loading
   * @returns the human readable light info
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric", "Clustered"][this.getTypeID()];
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  }
  /** @internal */
  _syncParentEnabledState() {
    super._syncParentEnabledState();
    if (!this.isDisposed()) {
      this._resyncMeshes();
    }
  }
  /**
   * Set the enabled state of this node.
   * @param value - the new enabled state
   */
  setEnabled(value) {
    super.setEnabled(value);
    this._resyncMeshes();
  }
  /**
   * Returns the Light associated shadow generator if any.
   * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator
   * @returns the associated shadow generator.
   */
  getShadowGenerator(camera = null) {
    if (this._shadowGenerators === null) {
      return null;
    }
    return this._shadowGenerators.get(camera) ?? null;
  }
  /**
   * Returns all the shadow generators associated to this light
   * @returns
   */
  getShadowGenerators() {
    return this._shadowGenerators;
  }
  /**
   * Returns a Vector3, the absolute light position in the World.
   * @returns the world space position of the light
   */
  getAbsolutePosition() {
    return Vector3.Zero();
  }
  /**
   * Specifies if the light will affect the passed mesh.
   * @param mesh The mesh to test against the light
   * @returns true the mesh is affected otherwise, false.
   */
  canAffectMesh(mesh) {
    if (!mesh) {
      return true;
    }
    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
      return false;
    }
    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
      return false;
    }
    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
      return false;
    }
    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
      return false;
    }
    return true;
  }
  /**
   * Releases resources associated with this node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    if (this._shadowGenerators) {
      const iterator = this._shadowGenerators.values();
      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
        const shadowGenerator = key.value;
        shadowGenerator.dispose();
      }
      this._shadowGenerators = null;
    }
    this.getScene().stopAnimation(this);
    if (this._parentContainer) {
      const index = this._parentContainer.lights.indexOf(this);
      if (index > -1) {
        this._parentContainer.lights.splice(index, 1);
      }
      this._parentContainer = null;
    }
    for (const mesh of this.getScene().meshes) {
      mesh._removeLightSource(this, true);
    }
    this._uniformBuffer.dispose();
    this.getScene().removeLight(this);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * Returns the light type ID (integer).
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTypeID() {
    return 0;
  }
  /**
   * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
   * @returns the scaled intensity in intensity mode unit
   */
  getScaledIntensity() {
    return this._photometricScale * this.intensity;
  }
  /**
   * Returns a new Light object, named "name", from the current one.
   * @param name The name of the cloned light
   * @param newParent The parent of this light, if it has one
   * @returns the new created light
   */
  clone(name, newParent = null) {
    const constructor = _Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());
    if (!constructor) {
      return null;
    }
    const clonedLight = SerializationHelper.Clone(constructor, this);
    if (name) {
      clonedLight.name = name;
    }
    if (newParent) {
      clonedLight.parent = newParent;
    }
    clonedLight.setEnabled(this.isEnabled());
    this.onClonedObservable.notifyObservers(clonedLight);
    return clonedLight;
  }
  /**
   * Serializes the current light into a Serialization object.
   * @returns the serialized object.
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getTypeID();
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    if (this.excludedMeshes.length > 0) {
      serializationObject.excludedMeshesIds = [];
      for (const mesh of this.excludedMeshes) {
        serializationObject.excludedMeshesIds.push(mesh.id);
      }
    }
    if (this.includedOnlyMeshes.length > 0) {
      serializationObject.includedOnlyMeshesIds = [];
      for (const mesh of this.includedOnlyMeshes) {
        serializationObject.includedOnlyMeshesIds.push(mesh.id);
      }
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  /**
   * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
   * This new light is named "name" and added to the passed scene.
   * @param type Type according to the types available in Light.LIGHTTYPEID_x
   * @param name The friendly name of the light
   * @param scene The scene the new light will belong to
   * @returns the constructor function
   */
  static GetConstructorFromName(type, name, scene) {
    const constructorFunc = Node.Construct("Light_Type_" + type, name, scene);
    if (constructorFunc) {
      return constructorFunc;
    }
    return null;
  }
  /**
   * Parses the passed "parsedLight" and returns a new instanced Light from this parsing.
   * @param parsedLight The JSON representation of the light
   * @param scene The scene to create the parsed light in
   * @returns the created light after parsing
   */
  static Parse(parsedLight, scene) {
    const constructor = _Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
    if (!constructor) {
      return null;
    }
    const light = SerializationHelper.Parse(constructor, parsedLight, scene);
    if (parsedLight.excludedMeshesIds) {
      light._excludedMeshesIds = parsedLight.excludedMeshesIds;
    }
    if (parsedLight.includedOnlyMeshesIds) {
      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
    }
    if (parsedLight.parentId !== void 0) {
      light._waitingParentId = parsedLight.parentId;
    }
    if (parsedLight.parentInstanceIndex !== void 0) {
      light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;
    }
    if (parsedLight.falloffType !== void 0) {
      light.falloffType = parsedLight.falloffType;
    }
    if (parsedLight.lightmapMode !== void 0) {
      light.lightmapMode = parsedLight.lightmapMode;
    }
    if (parsedLight.animations) {
      for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
        const parsedAnimation = parsedLight.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          light.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(light, parsedLight, scene);
    }
    if (parsedLight.autoAnimate) {
      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
    }
    if (parsedLight.isEnabled !== void 0) {
      light.setEnabled(parsedLight.isEnabled);
    }
    return light;
  }
  _hookArrayForExcluded(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      for (const item of items) {
        item._resyncLightSource(this);
      }
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      for (const item of deleted) {
        item._resyncLightSource(this);
      }
      return deleted;
    };
    for (const item of array) {
      item._resyncLightSource(this);
    }
  }
  _hookArrayForIncludedOnly(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      this._resyncMeshes();
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      this._resyncMeshes();
      return deleted;
    };
    this._resyncMeshes();
  }
  _resyncMeshes() {
    for (const mesh of this.getScene().meshes) {
      mesh._resyncLightSource(this);
    }
  }
  /**
   * Forces the meshes to update their light related information in their rendering used effects
   * @internal Internal Use Only
   */
  _markMeshesAsLightDirty() {
    for (const mesh of this.getScene().meshes) {
      if (mesh.lightSources.indexOf(this) !== -1) {
        mesh._markSubMeshesAsLightDirty();
      }
    }
  }
  /**
   * Recomputes the cached photometric scale if needed.
   */
  _computePhotometricScale() {
    this._photometricScale = this._getPhotometricScale();
    this.getScene().resetCachedMaterial();
  }
  /**
   * @returns the Photometric Scale according to the light type and intensity mode.
   */
  _getPhotometricScale() {
    let photometricScale = 0;
    const lightTypeID = this.getTypeID();
    let photometricMode = this.intensityMode;
    if (photometricMode === _Light.INTENSITYMODE_AUTOMATIC) {
      if (lightTypeID === _Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
        photometricMode = _Light.INTENSITYMODE_ILLUMINANCE;
      } else {
        photometricMode = _Light.INTENSITYMODE_LUMINOUSINTENSITY;
      }
    }
    switch (lightTypeID) {
      case _Light.LIGHTTYPEID_POINTLIGHT:
      case _Light.LIGHTTYPEID_SPOTLIGHT:
        switch (photometricMode) {
          case _Light.INTENSITYMODE_LUMINOUSPOWER:
            photometricScale = 1 / (4 * Math.PI);
            break;
          case _Light.INTENSITYMODE_LUMINOUSINTENSITY:
            photometricScale = 1;
            break;
          case _Light.INTENSITYMODE_LUMINANCE:
            photometricScale = this.radius * this.radius;
            break;
        }
        break;
      case _Light.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (photometricMode) {
          case _Light.INTENSITYMODE_ILLUMINANCE:
            photometricScale = 1;
            break;
          case _Light.INTENSITYMODE_LUMINANCE: {
            let apexAngleRadians = this.radius;
            apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
            const solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
            photometricScale = solidAngle;
            break;
          }
        }
        break;
      case _Light.LIGHTTYPEID_HEMISPHERICLIGHT:
        photometricScale = 1;
        break;
    }
    return photometricScale;
  }
  /**
   * Reorder the light in the scene according to their defined priority.
   * @internal Internal Use Only
   */
  _reorderLightsInScene() {
    const scene = this.getScene();
    if (this._renderPriority != 0) {
      scene.requireLightSorting = true;
    }
    this.getScene().sortLightsByPriority();
  }
  /**
   * @internal
   */
  _isReady() {
    return true;
  }
};
Light.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;
Light.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;
Light.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;
Light.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;
Light.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;
Light.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;
Light.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;
Light.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;
Light.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;
Light.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;
Light.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;
Light.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;
Light.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;
Light.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;
Light.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;
Light.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;
Light.LIGHTTYPEID_RECT_AREALIGHT = LightConstants.LIGHTTYPEID_RECT_AREALIGHT;
__decorate([
  serializeAsColor3()
], Light.prototype, "diffuse", void 0);
__decorate([
  serializeAsColor3()
], Light.prototype, "specular", void 0);
__decorate([
  serialize()
], Light.prototype, "falloffType", void 0);
__decorate([
  serialize()
], Light.prototype, "intensity", void 0);
__decorate([
  serialize()
], Light.prototype, "range", null);
__decorate([
  serialize()
], Light.prototype, "intensityMode", null);
__decorate([
  serialize()
], Light.prototype, "radius", null);
__decorate([
  serialize()
], Light.prototype, "_renderPriority", void 0);
__decorate([
  expandToProperty("_reorderLightsInScene")
], Light.prototype, "renderPriority", void 0);
__decorate([
  serialize("shadowEnabled")
], Light.prototype, "_shadowEnabled", void 0);
__decorate([
  serialize("excludeWithLayerMask")
], Light.prototype, "_excludeWithLayerMask", void 0);
__decorate([
  serialize("includeOnlyWithLayerMask")
], Light.prototype, "_includeOnlyWithLayerMask", void 0);
__decorate([
  serialize("lightmapMode")
], Light.prototype, "_lightmapMode", void 0);

// node_modules/@babylonjs/core/Lights/shadowLight.js
var ShadowLight = class extends Light {
  constructor() {
    super(...arguments);
    this._needProjectionMatrixCompute = true;
    this._viewMatrix = Matrix.Identity();
    this._projectionMatrix = Matrix.Identity();
  }
  _setPosition(value) {
    this._position = value;
  }
  /**
   * Sets the position the shadow will be casted from. Also use as the light position for both
   * point and spot lights.
   */
  get position() {
    return this._position;
  }
  /**
   * Sets the position the shadow will be casted from. Also use as the light position for both
   * point and spot lights.
   */
  set position(value) {
    this._setPosition(value);
  }
  _setDirection(value) {
    this._direction = value;
  }
  /**
   * In 2d mode (needCube being false), gets the direction used to cast the shadow.
   * Also use as the light direction on spot and directional lights.
   */
  get direction() {
    return this._direction;
  }
  /**
   * In 2d mode (needCube being false), sets the direction used to cast the shadow.
   * Also use as the light direction on spot and directional lights.
   */
  set direction(value) {
    this._setDirection(value);
  }
  /**
   * Gets the shadow projection clipping minimum z value.
   */
  get shadowMinZ() {
    return this._shadowMinZ;
  }
  /**
   * Sets the shadow projection clipping minimum z value.
   */
  set shadowMinZ(value) {
    this._shadowMinZ = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Sets the shadow projection clipping maximum z value.
   */
  get shadowMaxZ() {
    return this._shadowMaxZ;
  }
  /**
   * Gets the shadow projection clipping maximum z value.
   */
  set shadowMaxZ(value) {
    this._shadowMaxZ = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
   * @returns true if the information has been computed, false if it does not need to (no parenting)
   */
  computeTransformedInformation() {
    if (this.parent && this.parent.getWorldMatrix) {
      if (!this.transformedPosition) {
        this.transformedPosition = Vector3.Zero();
      }
      Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);
      if (this.direction) {
        if (!this.transformedDirection) {
          this.transformedDirection = Vector3.Zero();
        }
        Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);
      }
      return true;
    }
    return false;
  }
  /**
   * Return the depth scale used for the shadow map.
   * @returns the depth scale.
   */
  getDepthScale() {
    return 50;
  }
  /**
   * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
   * @param faceIndex The index of the face we are computed the direction to generate shadow
   * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getShadowDirection(faceIndex) {
    return this.transformedDirection ? this.transformedDirection : this.direction;
  }
  /**
   * If computeTransformedInformation has been called, returns the ShadowLight absolute position in the world. Otherwise, returns the local position.
   * @returns the position vector in world space
   */
  getAbsolutePosition() {
    return this.transformedPosition ? this.transformedPosition : this.position;
  }
  /**
   * Sets the ShadowLight direction toward the passed target.
   * @param target The point to target in local space
   * @returns the updated ShadowLight direction
   */
  setDirectionToTarget(target) {
    this.direction = Vector3.Normalize(target.subtract(this.position));
    return this.direction;
  }
  /**
   * Returns the light rotation in euler definition.
   * @returns the x y z rotation in local space.
   */
  getRotation() {
    this.direction.normalize();
    const xaxis = Vector3.Cross(this.direction, Axis.Y);
    const yaxis = Vector3.Cross(xaxis, this.direction);
    return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);
  }
  /**
   * Returns whether or not the shadow generation require a cube texture or a 2d texture.
   * @returns true if a cube texture needs to be use
   */
  needCube() {
    return false;
  }
  /**
   * Detects if the projection matrix requires to be recomputed this frame.
   * @returns true if it requires to be recomputed otherwise, false.
   */
  needProjectionMatrixCompute() {
    return this._needProjectionMatrixCompute;
  }
  /**
   * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
   */
  forceProjectionMatrixCompute() {
    this._needProjectionMatrixCompute = true;
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.position = Vector3.Zero();
  }
  /** @internal */
  _isSynchronized() {
    if (!this._cache.position.equals(this.position)) {
      return false;
    }
    return true;
  }
  /**
   * Computes the world matrix of the node
   * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
   * @returns the world matrix
   */
  computeWorldMatrix(force) {
    if (!force && this.isSynchronized()) {
      this._currentRenderId = this.getScene().getRenderId();
      return this._worldMatrix;
    }
    this._updateCache();
    this._cache.position.copyFrom(this.position);
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);
    if (this.parent && this.parent.getWorldMatrix) {
      this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);
      this._markSyncedWithParent();
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  }
  /**
   * Gets the minZ used for shadow according to both the scene and the light.
   * @param activeCamera The camera we are returning the min for
   * @returns the depth min z
   */
  getDepthMinZ(activeCamera) {
    return this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera?.minZ || 0;
  }
  /**
   * Gets the maxZ used for shadow according to both the scene and the light.
   * @param activeCamera The camera we are returning the max for
   * @returns the depth max z
   */
  getDepthMaxZ(activeCamera) {
    return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera?.maxZ || 1e4;
  }
  /**
   * Sets the shadow projection matrix in parameter to the generated projection matrix.
   * @param matrix The matrix to updated with the projection information
   * @param viewMatrix The transform matrix of the light
   * @param renderList The list of mesh to render in the map
   * @returns The current light
   */
  setShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    if (this.customProjectionMatrixBuilder) {
      this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);
    } else {
      this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
    return this;
  }
  /** @internal */
  _syncParentEnabledState() {
    super._syncParentEnabledState();
    if (!this.parent || !this.parent.getWorldMatrix) {
      this.transformedPosition = null;
      this.transformedDirection = null;
    }
  }
  /**
   * Returns the view matrix.
   * @param faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.
   * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getViewMatrix(faceIndex) {
    const lightDirection = TmpVectors.Vector3[0];
    let lightPosition = this.position;
    if (this.computeTransformedInformation()) {
      lightPosition = this.transformedPosition;
    }
    Vector3.NormalizeToRef(this.getShadowDirection(faceIndex), lightDirection);
    if (Math.abs(Vector3.Dot(lightDirection, Vector3.Up())) === 1) {
      lightDirection.z = 1e-13;
    }
    const lightTarget = TmpVectors.Vector3[1];
    lightPosition.addToRef(lightDirection, lightTarget);
    Matrix.LookAtLHToRef(lightPosition, lightTarget, Vector3.Up(), this._viewMatrix);
    return this._viewMatrix;
  }
  /**
   * Returns the projection matrix.
   * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).
   * @param viewMatrix The view transform matrix of the light (optional).
   * @param renderList The list of meshes to take into account when calculating the projection matrix (optional).
   * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getProjectionMatrix(viewMatrix, renderList) {
    this.setShadowProjectionMatrix(this._projectionMatrix, viewMatrix ?? this._viewMatrix, renderList ?? []);
    return this._projectionMatrix;
  }
};
__decorate([
  serializeAsVector3()
], ShadowLight.prototype, "position", null);
__decorate([
  serializeAsVector3()
], ShadowLight.prototype, "direction", null);
__decorate([
  serialize()
], ShadowLight.prototype, "shadowMinZ", null);
__decorate([
  serialize()
], ShadowLight.prototype, "shadowMaxZ", null);

export {
  UniformBuffer,
  Light,
  ShadowLight
};
//# sourceMappingURL=chunk-LOMHE2V5.js.map

import {
  DataBuffer
} from "./chunk-I2PO3XEU.js";
import {
  Effect,
  TimingTools
} from "./chunk-EH6DKOVC.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import {
  Observable
} from "./chunk-GCT36VBF.js";

// node_modules/@babylonjs/core/Buffers/bufferUtils.js
function GetFloatValue(dataView, type, byteOffset, normalized) {
  switch (type) {
    case 5120: {
      let value = dataView.getInt8(byteOffset);
      if (normalized) {
        value = Math.max(value / 127, -1);
      }
      return value;
    }
    case 5121: {
      let value = dataView.getUint8(byteOffset);
      if (normalized) {
        value = value / 255;
      }
      return value;
    }
    case 5122: {
      let value = dataView.getInt16(byteOffset, true);
      if (normalized) {
        value = Math.max(value / 32767, -1);
      }
      return value;
    }
    case 5123: {
      let value = dataView.getUint16(byteOffset, true);
      if (normalized) {
        value = value / 65535;
      }
      return value;
    }
    case 5124: {
      return dataView.getInt32(byteOffset, true);
    }
    case 5125: {
      return dataView.getUint32(byteOffset, true);
    }
    case 5126: {
      return dataView.getFloat32(byteOffset, true);
    }
    default: {
      throw new Error(`Invalid component type ${type}`);
    }
  }
}
function SetFloatValue(dataView, type, byteOffset, normalized, value) {
  switch (type) {
    case 5120: {
      if (normalized) {
        value = Math.round(value * 127);
      }
      dataView.setInt8(byteOffset, value);
      break;
    }
    case 5121: {
      if (normalized) {
        value = Math.round(value * 255);
      }
      dataView.setUint8(byteOffset, value);
      break;
    }
    case 5122: {
      if (normalized) {
        value = Math.round(value * 32767);
      }
      dataView.setInt16(byteOffset, value, true);
      break;
    }
    case 5123: {
      if (normalized) {
        value = Math.round(value * 65535);
      }
      dataView.setUint16(byteOffset, value, true);
      break;
    }
    case 5124: {
      dataView.setInt32(byteOffset, value, true);
      break;
    }
    case 5125: {
      dataView.setUint32(byteOffset, value, true);
      break;
    }
    case 5126: {
      dataView.setFloat32(byteOffset, value, true);
      break;
    }
    default: {
      throw new Error(`Invalid component type ${type}`);
    }
  }
}
function GetTypeByteLength(type) {
  switch (type) {
    case 5120:
    case 5121:
      return 1;
    case 5122:
    case 5123:
      return 2;
    case 5124:
    case 5125:
    case 5126:
      return 4;
    default:
      throw new Error(`Invalid type '${type}'`);
  }
}
function GetTypedArrayConstructor(componentType) {
  switch (componentType) {
    case 5120:
      return Int8Array;
    case 5121:
      return Uint8Array;
    case 5122:
      return Int16Array;
    case 5123:
      return Uint16Array;
    case 5124:
      return Int32Array;
    case 5125:
      return Uint32Array;
    case 5126:
      return Float32Array;
    default:
      throw new Error(`Invalid component type '${componentType}'`);
  }
}
function EnumerateFloatValues(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {
  const oldValues = new Array(componentCount);
  const newValues = new Array(componentCount);
  if (data instanceof Array) {
    let offset = byteOffset / 4;
    const stride = byteStride / 4;
    for (let index = 0; index < count; index += componentCount) {
      for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {
        oldValues[componentIndex] = newValues[componentIndex] = data[offset + componentIndex];
      }
      callback(newValues, index);
      for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {
        if (oldValues[componentIndex] !== newValues[componentIndex]) {
          data[offset + componentIndex] = newValues[componentIndex];
        }
      }
      offset += stride;
    }
  } else {
    const dataView = !ArrayBuffer.isView(data) ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);
    const componentByteLength = GetTypeByteLength(componentType);
    for (let index = 0; index < count; index += componentCount) {
      for (let componentIndex = 0, componentByteOffset = byteOffset; componentIndex < componentCount; componentIndex++, componentByteOffset += componentByteLength) {
        oldValues[componentIndex] = newValues[componentIndex] = GetFloatValue(dataView, componentType, componentByteOffset, normalized);
      }
      callback(newValues, index);
      for (let componentIndex = 0, componentByteOffset = byteOffset; componentIndex < componentCount; componentIndex++, componentByteOffset += componentByteLength) {
        if (oldValues[componentIndex] !== newValues[componentIndex]) {
          SetFloatValue(dataView, componentType, componentByteOffset, normalized, newValues[componentIndex]);
        }
      }
      byteOffset += byteStride;
    }
  }
}
function GetFloatData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy) {
  const tightlyPackedByteStride = size * GetTypeByteLength(type);
  const count = totalVertices * size;
  if (type !== 5126 || byteStride !== tightlyPackedByteStride) {
    const copy = new Float32Array(count);
    EnumerateFloatValues(data, byteOffset, byteStride, size, type, count, normalized, (values, index) => {
      for (let i = 0; i < size; i++) {
        copy[index + i] = values[i];
      }
    });
    return copy;
  }
  if (!(data instanceof Array || data instanceof Float32Array) || byteOffset !== 0 || data.length !== count) {
    if (data instanceof Array) {
      const offset = byteOffset / 4;
      return data.slice(offset, offset + count);
    } else if (data instanceof ArrayBuffer) {
      return new Float32Array(data, byteOffset, count);
    } else {
      const offset = data.byteOffset + byteOffset;
      if ((offset & 3) !== 0) {
        Logger.Warn("Float array must be aligned to 4-bytes border");
        forceCopy = true;
      }
      if (forceCopy) {
        return new Float32Array(data.buffer.slice(offset, offset + count * Float32Array.BYTES_PER_ELEMENT));
      } else {
        return new Float32Array(data.buffer, offset, count);
      }
    }
  }
  if (forceCopy) {
    return data.slice();
  }
  return data;
}
function GetTypedArrayData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy) {
  const typeByteLength = GetTypeByteLength(type);
  const constructor = GetTypedArrayConstructor(type);
  const count = totalVertices * size;
  if (Array.isArray(data)) {
    if ((byteOffset & 3) !== 0 || (byteStride & 3) !== 0) {
      throw new Error("byteOffset and byteStride must be a multiple of 4 for number[] data.");
    }
    const offset = byteOffset / 4;
    const stride = byteStride / 4;
    const lastIndex = offset + (totalVertices - 1) * stride + size;
    if (lastIndex > data.length) {
      throw new Error("Last accessed index is out of bounds.");
    }
    if (stride < size) {
      throw new Error("Data stride cannot be smaller than the component size.");
    }
    if (stride !== size) {
      const copy = new constructor(count);
      EnumerateFloatValues(data, byteOffset, byteStride, size, type, count, normalized, (values, index) => {
        for (let i = 0; i < size; i++) {
          copy[index + i] = values[i];
        }
      });
      return copy;
    }
    return new constructor(data.slice(offset, offset + count));
  }
  let buffer;
  let adjustedByteOffset = byteOffset;
  if (data instanceof ArrayBuffer) {
    buffer = data;
  } else {
    buffer = data.buffer;
    adjustedByteOffset += data.byteOffset;
  }
  const lastByteOffset = adjustedByteOffset + (totalVertices - 1) * byteStride + size * typeByteLength;
  if (lastByteOffset > buffer.byteLength) {
    throw new Error("Last accessed byte is out of bounds.");
  }
  const tightlyPackedByteStride = size * typeByteLength;
  if (byteStride < tightlyPackedByteStride) {
    throw new Error("Byte stride cannot be smaller than the component's byte size.");
  }
  if (byteStride !== tightlyPackedByteStride) {
    const copy = new constructor(count);
    EnumerateFloatValues(buffer, adjustedByteOffset, byteStride, size, type, count, normalized, (values, index) => {
      for (let i = 0; i < size; i++) {
        copy[index + i] = values[i];
      }
    });
    return copy;
  }
  if (typeByteLength !== 1 && (adjustedByteOffset & typeByteLength - 1) !== 0) {
    Logger.Warn("Array must be aligned to border of element size. Data will be copied.");
    forceCopy = true;
  }
  if (forceCopy) {
    return new constructor(buffer.slice(adjustedByteOffset, adjustedByteOffset + count * typeByteLength));
  }
  return new constructor(buffer, adjustedByteOffset, count);
}
function CopyFloatData(input, size, type, byteOffset, byteStride, normalized, totalVertices, output) {
  const tightlyPackedByteStride = size * GetTypeByteLength(type);
  const count = totalVertices * size;
  if (output.length !== count) {
    throw new Error("Output length is not valid");
  }
  if (type !== 5126 || byteStride !== tightlyPackedByteStride) {
    EnumerateFloatValues(input, byteOffset, byteStride, size, type, count, normalized, (values, index) => {
      for (let i = 0; i < size; i++) {
        output[index + i] = values[i];
      }
    });
    return;
  }
  if (input instanceof Array) {
    const offset = byteOffset / 4;
    output.set(input, offset);
  } else if (input instanceof ArrayBuffer) {
    const floatData = new Float32Array(input, byteOffset, count);
    output.set(floatData);
  } else {
    const offset = input.byteOffset + byteOffset;
    if ((offset & 3) !== 0) {
      Logger.Warn("Float array must be aligned to 4-bytes border");
      output.set(new Float32Array(input.buffer.slice(offset, offset + count * Float32Array.BYTES_PER_ELEMENT)));
      return;
    }
    const floatData = new Float32Array(input.buffer, offset, count);
    output.set(floatData);
  }
}

// node_modules/@babylonjs/core/Buffers/buffer.js
var Buffer = class {
  /**
   * Gets a boolean indicating if the Buffer is disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Constructor
   * @param engine the engine
   * @param data the data to use for this buffer
   * @param updatable whether the data is updatable
   * @param stride the stride (optional)
   * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)
   * @param instanced whether the buffer is instanced (optional)
   * @param useBytes set to true if the stride in in bytes (optional)
   * @param divisor sets an optional divisor for instances (1 by default)
   * @param label defines the label of the buffer (for debug purpose)
   */
  constructor(engine, data, updatable, stride = 0, postponeInternalCreation = false, instanced = false, useBytes = false, divisor, label) {
    this._isAlreadyOwned = false;
    this._isDisposed = false;
    if (engine && engine.getScene) {
      this._engine = engine.getScene().getEngine();
    } else {
      this._engine = engine;
    }
    this._updatable = updatable;
    this._instanced = instanced;
    this._divisor = divisor || 1;
    this._label = label;
    if (data instanceof DataBuffer) {
      this._data = null;
      this._buffer = data;
    } else {
      this._data = data;
      this._buffer = null;
    }
    this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;
    if (!postponeInternalCreation) {
      this.create();
    }
  }
  /**
   * Create a new VertexBuffer based on the current buffer
   * @param kind defines the vertex buffer kind (position, normal, etc.)
   * @param offset defines offset in the buffer (0 by default)
   * @param size defines the size in floats of attributes (position is 3 for instance)
   * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)
   * @param instanced defines if the vertex buffer contains indexed data
   * @param useBytes defines if the offset and stride are in bytes     *
   * @param divisor sets an optional divisor for instances (1 by default)
   * @returns the new vertex buffer
   */
  createVertexBuffer(kind, offset, size, stride, instanced, useBytes = false, divisor) {
    const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;
    const byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
    return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === void 0 ? this._instanced : instanced, byteOffset, size, void 0, void 0, true, this._divisor || divisor);
  }
  // Properties
  /**
   * Gets a boolean indicating if the Buffer is updatable?
   * @returns true if the buffer is updatable
   */
  isUpdatable() {
    return this._updatable;
  }
  /**
   * Gets current buffer's data
   * @returns a DataArray or null
   */
  getData() {
    return this._data;
  }
  /**
   * Gets underlying native buffer
   * @returns underlying native buffer
   */
  getBuffer() {
    return this._buffer;
  }
  /**
   * Gets the stride in float32 units (i.e. byte stride / 4).
   * May not be an integer if the byte stride is not divisible by 4.
   * @returns the stride in float32 units
   * @deprecated Please use byteStride instead.
   */
  getStrideSize() {
    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
  }
  // Methods
  /**
   * Store data into the buffer. Creates the buffer if not used already.
   * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.
   * @param data defines the data to store
   */
  create(data = null) {
    if (!data && this._buffer) {
      return;
    }
    data = data || this._data;
    if (!data) {
      return;
    }
    if (!this._buffer) {
      if (this._updatable) {
        this._buffer = this._engine.createDynamicVertexBuffer(data, this._label);
        this._data = data;
      } else {
        this._buffer = this._engine.createVertexBuffer(data, void 0, this._label);
      }
    } else if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data);
      this._data = data;
    }
  }
  /** @internal */
  _rebuild() {
    if (!this._data) {
      if (!this._buffer) {
        return;
      }
      if (this._buffer.capacity > 0) {
        if (this._updatable) {
          this._buffer = this._engine.createDynamicVertexBuffer(this._buffer.capacity, this._label);
        } else {
          this._buffer = this._engine.createVertexBuffer(this._buffer.capacity, void 0, this._label);
        }
        return;
      }
      Logger.Warn(`Missing data for buffer "${this._label}" ${this._buffer ? "(uniqueId: " + this._buffer.uniqueId + ")" : ""}. Buffer reconstruction failed.`);
      this._buffer = null;
    } else {
      this._buffer = null;
      this.create(this._data);
    }
  }
  /**
   * Update current buffer data
   * @param data defines the data to store
   */
  update(data) {
    this.create(data);
  }
  /**
   * Updates the data directly.
   * @param data the new data
   * @param offset the new offset
   * @param vertexCount the vertex count (optional)
   * @param useBytes set to true if the offset is in bytes
   */
  updateDirectly(data, offset, vertexCount, useBytes = false) {
    if (!this._buffer) {
      return;
    }
    if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : void 0);
      if (offset === 0 && vertexCount === void 0) {
        this._data = data;
      } else {
        this._data = null;
      }
    }
  }
  /** @internal */
  _increaseReferences() {
    if (!this._buffer) {
      return;
    }
    if (!this._isAlreadyOwned) {
      this._isAlreadyOwned = true;
      return;
    }
    this._buffer.references++;
  }
  /**
   * Release all resources
   */
  dispose() {
    if (!this._buffer) {
      return;
    }
    if (this._engine._releaseBuffer(this._buffer)) {
      this._isDisposed = true;
      this._data = null;
      this._buffer = null;
    }
  }
};
var VertexBuffer = class _VertexBuffer {
  /**
   * Gets a boolean indicating if the Buffer is disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Gets or sets the instance divisor when in instanced mode
   */
  get instanceDivisor() {
    return this._instanceDivisor;
  }
  set instanceDivisor(value) {
    const isInstanced = value != 0;
    this._instanceDivisor = value;
    if (isInstanced !== this._instanced) {
      this._instanced = isInstanced;
      this._computeHashCode();
    }
  }
  /**
   * Gets the max possible amount of vertices stored within the current vertex buffer.
   * We do not have the end offset or count so this will be too big for concatenated vertex buffers.
   * @internal
   */
  get _maxVerticesCount() {
    const data = this.getData();
    if (!data) {
      return 0;
    }
    if (Array.isArray(data)) {
      return data.length / (this.byteStride / 4) - this.byteOffset / 4;
    }
    return (data.byteLength - this.byteOffset) / this.byteStride;
  }
  /** @internal */
  constructor(engine, data, kind, updatableOrOptions, postponeInternalCreation, stride, instanced, offset, size, type, normalized = false, useBytes = false, divisor = 1, takeBufferOwnership = false) {
    this._isDisposed = false;
    let updatable = false;
    this.engine = engine;
    if (typeof updatableOrOptions === "object" && updatableOrOptions !== null) {
      updatable = updatableOrOptions.updatable ?? false;
      postponeInternalCreation = updatableOrOptions.postponeInternalCreation;
      stride = updatableOrOptions.stride;
      instanced = updatableOrOptions.instanced;
      offset = updatableOrOptions.offset;
      size = updatableOrOptions.size;
      type = updatableOrOptions.type;
      normalized = updatableOrOptions.normalized ?? false;
      useBytes = updatableOrOptions.useBytes ?? false;
      divisor = updatableOrOptions.divisor ?? 1;
      takeBufferOwnership = updatableOrOptions.takeBufferOwnership ?? false;
      this._label = updatableOrOptions.label;
    } else {
      updatable = !!updatableOrOptions;
    }
    if (data instanceof Buffer) {
      this._buffer = data;
      this._ownsBuffer = takeBufferOwnership;
    } else {
      this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor, this._label);
      this._ownsBuffer = true;
    }
    this.uniqueId = _VertexBuffer._Counter++;
    this._kind = kind;
    if (type === void 0) {
      const vertexData = this.getData();
      this.type = vertexData ? _VertexBuffer.GetDataType(vertexData) : _VertexBuffer.FLOAT;
    } else {
      this.type = type;
    }
    const typeByteLength = GetTypeByteLength(this.type);
    if (useBytes) {
      this._size = size || (stride ? stride / typeByteLength : _VertexBuffer.DeduceStride(kind));
      this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = offset || 0;
    } else {
      this._size = size || stride || _VertexBuffer.DeduceStride(kind);
      this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = (offset || 0) * typeByteLength;
    }
    this.normalized = normalized;
    this._instanced = instanced !== void 0 ? instanced : false;
    this._instanceDivisor = instanced ? divisor : 0;
    this._alignBuffer();
    this._computeHashCode();
  }
  _computeHashCode() {
    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + /* keep 5 bits free */
    (this.byteStride << 12);
  }
  /** @internal */
  _rebuild() {
    this._buffer?._rebuild();
  }
  /**
   * Returns the kind of the VertexBuffer (string)
   * @returns a string
   */
  getKind() {
    return this._kind;
  }
  // Properties
  /**
   * Gets a boolean indicating if the VertexBuffer is updatable?
   * @returns true if the buffer is updatable
   */
  isUpdatable() {
    return this._buffer.isUpdatable();
  }
  /**
   * Gets the raw data from the underlying buffer.
   * Note: The data may include more than just this vertex buffer's values.
   * @returns the buffer data as a DataArray, or null.
   */
  getData() {
    return this._buffer.getData();
  }
  /**
   * Gets this vertex buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.
   * @param totalVertices number of vertices in the buffer to take into account
   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
   * @returns a float array containing vertex data
   */
  getFloatData(totalVertices, forceCopy) {
    const data = this.getData();
    if (!data) {
      return null;
    }
    return GetFloatData(data, this._size, this.type, this.byteOffset, this.byteStride, this.normalized, totalVertices, forceCopy);
  }
  /**
   * Gets underlying native buffer
   * @returns underlying native buffer
   */
  getBuffer() {
    return this._buffer.getBuffer();
  }
  /**
   * Gets the Buffer instance that wraps the native GPU buffer
   * @returns the wrapper buffer
   */
  getWrapperBuffer() {
    return this._buffer;
  }
  /**
   * Gets the stride in float32 units (i.e. byte stride / 4).
   * May not be an integer if the byte stride is not divisible by 4.
   * @returns the stride in float32 units
   * @deprecated Please use byteStride instead.
   */
  getStrideSize() {
    return this.byteStride / GetTypeByteLength(this.type);
  }
  /**
   * Returns the offset as a multiple of the type byte length.
   * @returns the offset in bytes
   * @deprecated Please use byteOffset instead.
   */
  getOffset() {
    return this.byteOffset / GetTypeByteLength(this.type);
  }
  /**
   * Returns the number of components or the byte size per vertex attribute
   * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)
   * @returns the number of components
   */
  getSize(sizeInBytes = false) {
    return sizeInBytes ? this._size * GetTypeByteLength(this.type) : this._size;
  }
  /**
   * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced
   * @returns true if this buffer is instanced
   */
  getIsInstanced() {
    return this._instanced;
  }
  /**
   * Returns the instancing divisor, zero for non-instanced (integer).
   * @returns a number
   */
  getInstanceDivisor() {
    return this._instanceDivisor;
  }
  // Methods
  /**
   * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property
   * @param data defines the data to store
   */
  create(data) {
    this._buffer.create(data);
    this._alignBuffer();
  }
  /**
   * Updates the underlying buffer according to the passed numeric array or Float32Array.
   * This function will create a new buffer if the current one is not updatable
   * @param data defines the data to store
   */
  update(data) {
    this._buffer.update(data);
    this._alignBuffer();
  }
  /**
   * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.
   * Returns the directly updated WebGLBuffer.
   * @param data the new data
   * @param offset the new offset
   * @param useBytes set to true if the offset is in bytes
   */
  updateDirectly(data, offset, useBytes = false) {
    this._buffer.updateDirectly(data, offset, void 0, useBytes);
    this._alignBuffer();
  }
  /**
   * Disposes the VertexBuffer and the underlying WebGLBuffer.
   */
  dispose() {
    if (this._ownsBuffer) {
      this._buffer.dispose();
    }
    this._isDisposed = true;
  }
  /**
   * Enumerates each value of this vertex buffer as numbers.
   * @param count the number of values to enumerate
   * @param callback the callback function called for each value
   */
  forEach(count, callback) {
    EnumerateFloatValues(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, (values, index) => {
      for (let i = 0; i < this._size; i++) {
        callback(values[i], index + i);
      }
    });
  }
  /** @internal */
  _alignBuffer() {
  }
  /**
   * Deduces the stride given a kind.
   * @param kind The kind string to deduce
   * @returns The deduced stride
   */
  static DeduceStride(kind) {
    switch (kind) {
      case _VertexBuffer.UVKind:
      case _VertexBuffer.UV2Kind:
      case _VertexBuffer.UV3Kind:
      case _VertexBuffer.UV4Kind:
      case _VertexBuffer.UV5Kind:
      case _VertexBuffer.UV6Kind:
        return 2;
      case _VertexBuffer.NormalKind:
      case _VertexBuffer.PositionKind:
        return 3;
      case _VertexBuffer.ColorKind:
      case _VertexBuffer.ColorInstanceKind:
      case _VertexBuffer.MatricesIndicesKind:
      case _VertexBuffer.MatricesIndicesExtraKind:
      case _VertexBuffer.MatricesWeightsKind:
      case _VertexBuffer.MatricesWeightsExtraKind:
      case _VertexBuffer.TangentKind:
        return 4;
      default:
        throw new Error("Invalid kind '" + kind + "'");
    }
  }
  /**
   * Gets the vertex buffer type of the given data array.
   * @param data the data array
   * @returns the vertex buffer type
   */
  static GetDataType(data) {
    if (data instanceof Int8Array) {
      return _VertexBuffer.BYTE;
    } else if (data instanceof Uint8Array) {
      return _VertexBuffer.UNSIGNED_BYTE;
    } else if (data instanceof Int16Array) {
      return _VertexBuffer.SHORT;
    } else if (data instanceof Uint16Array) {
      return _VertexBuffer.UNSIGNED_SHORT;
    } else if (data instanceof Int32Array) {
      return _VertexBuffer.INT;
    } else if (data instanceof Uint32Array) {
      return _VertexBuffer.UNSIGNED_INT;
    } else {
      return _VertexBuffer.FLOAT;
    }
  }
  /**
   * Gets the byte length of the given type.
   * @param type the type
   * @returns the number of bytes
   * @deprecated Use `getTypeByteLength` from `bufferUtils` instead
   */
  static GetTypeByteLength(type) {
    return GetTypeByteLength(type);
  }
  /**
   * Enumerates each value of the given parameters as numbers.
   * @param data the data to enumerate
   * @param byteOffset the byte offset of the data
   * @param byteStride the byte stride of the data
   * @param componentCount the number of components per element
   * @param componentType the type of the component
   * @param count the number of values to enumerate
   * @param normalized whether the data is normalized
   * @param callback the callback function called for each value
   * @deprecated Use `EnumerateFloatValues` from `bufferUtils` instead
   */
  static ForEach(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {
    EnumerateFloatValues(data, byteOffset, byteStride, componentCount, componentType, count, normalized, (values, index) => {
      for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {
        callback(values[componentIndex], index + componentIndex);
      }
    });
  }
  /**
   * Gets the given data array as a float array. Float data is constructed if the data array cannot be returned directly.
   * @param data the input data array
   * @param size the number of components
   * @param type the component type
   * @param byteOffset the byte offset of the data
   * @param byteStride the byte stride of the data
   * @param normalized whether the data is normalized
   * @param totalVertices number of vertices in the buffer to take into account
   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
   * @returns a float array containing vertex data
   * @deprecated Use `GetFloatData` from `bufferUtils` instead
   */
  static GetFloatData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy) {
    return GetFloatData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy);
  }
};
VertexBuffer._Counter = 0;
VertexBuffer.BYTE = 5120;
VertexBuffer.UNSIGNED_BYTE = 5121;
VertexBuffer.SHORT = 5122;
VertexBuffer.UNSIGNED_SHORT = 5123;
VertexBuffer.INT = 5124;
VertexBuffer.UNSIGNED_INT = 5125;
VertexBuffer.FLOAT = 5126;
VertexBuffer.PositionKind = `position`;
VertexBuffer.NormalKind = `normal`;
VertexBuffer.TangentKind = `tangent`;
VertexBuffer.UVKind = `uv`;
VertexBuffer.UV2Kind = `uv2`;
VertexBuffer.UV3Kind = `uv3`;
VertexBuffer.UV4Kind = `uv4`;
VertexBuffer.UV5Kind = `uv5`;
VertexBuffer.UV6Kind = `uv6`;
VertexBuffer.ColorKind = `color`;
VertexBuffer.ColorInstanceKind = `instanceColor`;
VertexBuffer.MatricesIndicesKind = `matricesIndices`;
VertexBuffer.MatricesWeightsKind = `matricesWeights`;
VertexBuffer.MatricesIndicesExtraKind = `matricesIndicesExtra`;
VertexBuffer.MatricesWeightsExtraKind = `matricesWeightsExtra`;

// node_modules/@babylonjs/core/Maths/math.viewport.js
var Viewport = class _Viewport {
  /**
   * Creates a Viewport object located at (x, y) and sized (width, height)
   * @param x defines viewport left coordinate
   * @param y defines viewport top coordinate
   * @param width defines the viewport width
   * @param height defines the viewport height
   */
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  /**
   * Creates a new viewport using absolute sizing (from 0-> width, 0-> height instead of 0->1)
   * @param renderWidth defines the rendering width
   * @param renderHeight defines the rendering height
   * @returns a new Viewport
   */
  toGlobal(renderWidth, renderHeight) {
    return new _Viewport(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);
  }
  /**
   * Stores absolute viewport value into a target viewport (from 0-> width, 0-> height instead of 0->1)
   * @param renderWidth defines the rendering width
   * @param renderHeight defines the rendering height
   * @param ref defines the target viewport
   * @returns the current viewport
   */
  toGlobalToRef(renderWidth, renderHeight, ref) {
    ref.x = this.x * renderWidth;
    ref.y = this.y * renderHeight;
    ref.width = this.width * renderWidth;
    ref.height = this.height * renderHeight;
    return this;
  }
  /**
   * Returns a new Viewport copied from the current one
   * @returns a new Viewport
   */
  clone() {
    return new _Viewport(this.x, this.y, this.width, this.height);
  }
};

// node_modules/@babylonjs/core/Materials/drawWrapper.js
var DrawWrapper = class {
  /**
   * Retrieves the effect from a DrawWrapper or Effect instance.
   * @param effect The effect or DrawWrapper instance to retrieve the effect from.
   * @returns The effect associated with the given instance, or null if not found.
   */
  static GetEffect(effect) {
    return effect.getPipelineContext === void 0 ? effect.effect : effect;
  }
  /**
   * Creates a new DrawWrapper instance.
   * Note that drawContext is always created (but may end up being undefined if the engine doesn't need draw contexts), but materialContext is optional.
   * @param engine The engine to create the draw wrapper for.
   * @param createMaterialContext If true, creates a material context for this wrapper (default is true).
   */
  constructor(engine, createMaterialContext = true) {
    this._wasPreviouslyReady = false;
    this._forceRebindOnNextCall = true;
    this._wasPreviouslyUsingInstances = null;
    this.effect = null;
    this.defines = null;
    this.drawContext = engine.createDrawContext();
    if (createMaterialContext) {
      this.materialContext = engine.createMaterialContext();
    }
  }
  /**
   * Sets the effect and its associated defines for this wrapper.
   * @param effect The effect to associate with this wrapper.
   * @param defines The defines to associate with this wrapper.
   * @param resetContext If true, resets the draw context (default is true).
   */
  setEffect(effect, defines, resetContext = true) {
    this.effect = effect;
    if (defines !== void 0) {
      this.defines = defines;
    }
    if (resetContext) {
      this.drawContext?.reset();
    }
  }
  /**
   * Disposes the effect wrapper and its resources
   * @param immediate if the effect should be disposed immediately or on the next frame.
   * If dispose() is not called during a scene or engine dispose, we want to delay the dispose of the underlying effect. Mostly to give a chance to user code to reuse the effect in some way.
   */
  dispose(immediate = false) {
    if (this.effect) {
      const effect = this.effect;
      if (immediate) {
        effect.dispose();
      } else {
        TimingTools.SetImmediate(() => {
          effect.getEngine().onEndFrameObservable.addOnce(() => {
            effect.dispose();
          });
        });
      }
      this.effect = null;
    }
    this.drawContext?.dispose();
  }
};

// node_modules/@babylonjs/core/Materials/effectRenderer.js
var DefaultOptions = {
  positions: [1, 1, -1, 1, -1, -1, 1, -1],
  indices: [0, 1, 2, 0, 2, 3]
};
var EffectRenderer = class {
  /**
   * Creates an effect renderer
   * @param engine the engine to use for rendering
   * @param options defines the options of the effect renderer
   */
  constructor(engine, options = DefaultOptions) {
    this._fullscreenViewport = new Viewport(0, 0, 1, 1);
    const positions = options.positions ?? DefaultOptions.positions;
    const indices = options.indices ?? DefaultOptions.indices;
    this.engine = engine;
    this._vertexBuffers = {
      // Note, always assumes stride of 2.
      [VertexBuffer.PositionKind]: new VertexBuffer(engine, positions, VertexBuffer.PositionKind, false, false, 2)
    };
    this._indexBuffer = engine.createIndexBuffer(indices);
    this._indexBufferLength = indices.length;
    this._onContextRestoredObserver = engine.onContextRestoredObservable.add(() => {
      this._indexBuffer = engine.createIndexBuffer(indices);
      for (const key in this._vertexBuffers) {
        const vertexBuffer = this._vertexBuffers[key];
        vertexBuffer._rebuild();
      }
    });
  }
  /**
   * Sets the current viewport in normalized coordinates 0-1
   * @param viewport Defines the viewport to set (defaults to 0 0 1 1)
   */
  setViewport(viewport = this._fullscreenViewport) {
    this.engine.setViewport(viewport);
  }
  /**
   * Binds the embedded attributes buffer to the effect.
   * @param effect Defines the effect to bind the attributes for
   */
  bindBuffers(effect) {
    this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
  }
  /**
   * Sets the current effect wrapper to use during draw.
   * The effect needs to be ready before calling this api.
   * This also sets the default full screen position attribute.
   * @param effectWrapper Defines the effect to draw with
   * @param depthTest Whether to enable depth testing (default: false)
   * @param stencilTest Whether to enable stencil testing (default: false)
   */
  applyEffectWrapper(effectWrapper, depthTest = false, stencilTest = false) {
    this.engine.setState(true);
    this.engine.depthCullingState.depthTest = depthTest;
    this.engine.stencilState.stencilTest = stencilTest;
    this.engine.enableEffect(effectWrapper.drawWrapper);
    this.bindBuffers(effectWrapper.effect);
    effectWrapper.onApplyObservable.notifyObservers({});
  }
  /**
   * Saves engine states
   */
  saveStates() {
    this._savedStateDepthTest = this.engine.depthCullingState.depthTest;
    this._savedStateStencilTest = this.engine.stencilState.stencilTest;
  }
  /**
   * Restores engine states
   */
  restoreStates() {
    this.engine.depthCullingState.depthTest = this._savedStateDepthTest;
    this.engine.stencilState.stencilTest = this._savedStateStencilTest;
  }
  /**
   * Draws a full screen quad.
   */
  draw() {
    this.engine.drawElementsType(0, 0, this._indexBufferLength);
  }
  _isRenderTargetTexture(texture) {
    return texture.renderTarget !== void 0;
  }
  /**
   * renders one or more effects to a specified texture
   * @param effectWrapper the effect to renderer
   * @param outputTexture texture to draw to, if null it will render to the currently bound frame buffer
   */
  render(effectWrapper, outputTexture = null) {
    if (!effectWrapper.effect.isReady()) {
      return;
    }
    this.saveStates();
    this.setViewport();
    const out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget : outputTexture;
    if (out) {
      this.engine.bindFramebuffer(out);
    }
    this.applyEffectWrapper(effectWrapper);
    this.draw();
    if (out) {
      this.engine.unBindFramebuffer(out);
    }
    this.restoreStates();
  }
  /**
   * Disposes of the effect renderer
   */
  dispose() {
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      delete this._vertexBuffers[VertexBuffer.PositionKind];
    }
    if (this._indexBuffer) {
      this.engine._releaseBuffer(this._indexBuffer);
    }
    if (this._onContextRestoredObserver) {
      this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);
      this._onContextRestoredObserver = null;
    }
  }
};
var EffectWrapper = class _EffectWrapper {
  /**
   * Registers a shader code processing with an effect wrapper name.
   * @param effectWrapperName name of the effect wrapper. Use null for the fallback shader code processing. This is the shader code processing that will be used in case no specific shader code processing has been associated to an effect wrapper name
   * @param customShaderCodeProcessing shader code processing to associate to the effect wrapper name
   */
  static RegisterShaderCodeProcessing(effectWrapperName, customShaderCodeProcessing) {
    if (!customShaderCodeProcessing) {
      delete _EffectWrapper._CustomShaderCodeProcessing[effectWrapperName ?? ""];
      return;
    }
    _EffectWrapper._CustomShaderCodeProcessing[effectWrapperName ?? ""] = customShaderCodeProcessing;
  }
  static _GetShaderCodeProcessing(effectWrapperName) {
    return _EffectWrapper._CustomShaderCodeProcessing[effectWrapperName] ?? _EffectWrapper._CustomShaderCodeProcessing[""];
  }
  /**
   * Gets or sets the name of the effect wrapper
   */
  get name() {
    return this.options.name;
  }
  set name(value) {
    this.options.name = value;
  }
  /**
   * Get a value indicating if the effect is ready to be used
   * @returns true if the post-process is ready (shader is compiled)
   */
  isReady() {
    return this._drawWrapper.effect?.isReady() ?? false;
  }
  /**
   * Get the draw wrapper associated with the effect wrapper
   * @returns the draw wrapper associated with the effect wrapper
   */
  get drawWrapper() {
    return this._drawWrapper;
  }
  /**
   * The underlying effect
   */
  get effect() {
    return this._drawWrapper.effect;
  }
  set effect(effect) {
    this._drawWrapper.effect = effect;
  }
  /**
   * Creates an effect to be rendered
   * @param creationOptions options to create the effect
   */
  constructor(creationOptions) {
    this.alphaMode = 0;
    this.onEffectCreatedObservable = new Observable(void 0, true);
    this.onApplyObservable = new Observable();
    this._shadersLoaded = false;
    this._webGPUReady = false;
    this._importPromises = [];
    this.options = {
      ...creationOptions,
      name: creationOptions.name || "effectWrapper",
      engine: creationOptions.engine,
      uniforms: creationOptions.uniforms || creationOptions.uniformNames || [],
      uniformNames: void 0,
      samplers: creationOptions.samplers || creationOptions.samplerNames || [],
      samplerNames: void 0,
      attributeNames: creationOptions.attributeNames || ["position"],
      uniformBuffers: creationOptions.uniformBuffers || [],
      defines: creationOptions.defines || "",
      useShaderStore: creationOptions.useShaderStore || false,
      vertexUrl: creationOptions.vertexUrl || creationOptions.vertexShader || "postprocess",
      vertexShader: void 0,
      fragmentShader: creationOptions.fragmentShader || "pass",
      indexParameters: creationOptions.indexParameters,
      blockCompilation: creationOptions.blockCompilation || false,
      shaderLanguage: creationOptions.shaderLanguage || 0,
      onCompiled: creationOptions.onCompiled || void 0,
      extraInitializations: creationOptions.extraInitializations || void 0,
      extraInitializationsAsync: creationOptions.extraInitializationsAsync || void 0,
      useAsPostProcess: creationOptions.useAsPostProcess ?? false,
      allowEmptySourceTexture: creationOptions.allowEmptySourceTexture ?? false
    };
    this.options.uniformNames = this.options.uniforms;
    this.options.samplerNames = this.options.samplers;
    this.options.vertexShader = this.options.vertexUrl;
    if (this.options.useAsPostProcess) {
      if (!this.options.allowEmptySourceTexture && this.options.samplers.indexOf("textureSampler") === -1) {
        this.options.samplers.push("textureSampler");
      }
      if (this.options.uniforms.indexOf("scale") === -1) {
        this.options.uniforms.push("scale");
      }
    }
    if (creationOptions.vertexUrl || creationOptions.vertexShader) {
      this._shaderPath = {
        vertexSource: this.options.vertexShader
      };
    } else {
      if (!this.options.useAsPostProcess) {
        this.options.uniforms.push("scale");
        this.onApplyObservable.add(() => {
          this.effect.setFloat2("scale", 1, 1);
        });
      }
      this._shaderPath = {
        vertex: this.options.vertexShader
      };
    }
    this._shaderPath.fragmentSource = this.options.fragmentShader;
    this._shaderPath.spectorName = this.options.name;
    if (this.options.useShaderStore) {
      this._shaderPath.fragment = this._shaderPath.fragmentSource;
      if (!this._shaderPath.vertex) {
        this._shaderPath.vertex = this._shaderPath.vertexSource;
      }
      delete this._shaderPath.fragmentSource;
      delete this._shaderPath.vertexSource;
    }
    this.onApplyObservable.add(() => {
      this.bind();
    });
    if (!this.options.useShaderStore) {
      this._onContextRestoredObserver = this.options.engine.onContextRestoredObservable.add(() => {
        this.effect._pipelineContext = null;
        this.effect._prepareEffect();
      });
    }
    this._drawWrapper = new DrawWrapper(this.options.engine);
    this._webGPUReady = this.options.shaderLanguage === 1;
    const defines = Array.isArray(this.options.defines) ? this.options.defines.join("\n") : this.options.defines;
    this._postConstructor(this.options.blockCompilation, defines, this.options.extraInitializations);
  }
  _gatherImports(useWebGPU = false, list) {
    if (!this.options.useAsPostProcess) {
      return;
    }
    if (useWebGPU && this._webGPUReady) {
      list.push(Promise.all([import("./postprocess.vertex-SX6N7QRU.js")]));
    } else {
      list.push(Promise.all([import("./postprocess.vertex-WFPP5Y2L.js")]));
    }
  }
  /** @internal */
  _postConstructor(blockCompilation, defines = null, extraInitializations, importPromises) {
    this._importPromises.length = 0;
    if (importPromises) {
      this._importPromises.push(...importPromises);
    }
    const useWebGPU = this.options.engine.isWebGPU && !_EffectWrapper.ForceGLSL;
    this._gatherImports(useWebGPU, this._importPromises);
    if (extraInitializations !== void 0) {
      extraInitializations(useWebGPU, this._importPromises);
    }
    if (useWebGPU && this._webGPUReady) {
      this.options.shaderLanguage = 1;
    }
    if (!blockCompilation) {
      this.updateEffect(defines);
    }
  }
  /**
   * Updates the effect with the current effect wrapper compile time values and recompiles the shader.
   * @param defines Define statements that should be added at the beginning of the shader. (default: null)
   * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
   * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
   * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
   * @param onCompiled Called when the shader has been compiled.
   * @param onError Called if there is an error when compiling a shader.
   * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)
   * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)
   */
  updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {
    const customShaderCodeProcessing = _EffectWrapper._GetShaderCodeProcessing(this.name);
    if (customShaderCodeProcessing?.defineCustomBindings) {
      const newUniforms = uniforms?.slice() ?? [];
      newUniforms.push(...this.options.uniforms);
      const newSamplers = samplers?.slice() ?? [];
      newSamplers.push(...this.options.samplers);
      defines = customShaderCodeProcessing.defineCustomBindings(this.name, defines, newUniforms, newSamplers);
      uniforms = newUniforms;
      samplers = newSamplers;
    }
    this.options.defines = defines || "";
    const waitImportsLoaded = this._shadersLoaded || this._importPromises.length === 0 ? void 0 : async () => {
      await Promise.all(this._importPromises);
      this._shadersLoaded = true;
    };
    let extraInitializationsAsync;
    if (this.options.extraInitializationsAsync) {
      extraInitializationsAsync = async () => {
        waitImportsLoaded?.();
        await this.options.extraInitializationsAsync();
      };
    } else {
      extraInitializationsAsync = waitImportsLoaded;
    }
    if (this.options.useShaderStore) {
      this._drawWrapper.effect = this.options.engine.createEffect({ vertex: vertexUrl ?? this._shaderPath.vertex, fragment: fragmentUrl ?? this._shaderPath.fragment }, {
        attributes: this.options.attributeNames,
        uniformsNames: uniforms || this.options.uniforms,
        uniformBuffersNames: this.options.uniformBuffers,
        samplers: samplers || this.options.samplers,
        defines: defines !== null ? defines : "",
        fallbacks: null,
        onCompiled: onCompiled ?? this.options.onCompiled,
        onError: onError ?? null,
        indexParameters: indexParameters || this.options.indexParameters,
        processCodeAfterIncludes: customShaderCodeProcessing?.processCodeAfterIncludes ? (shaderType, code) => customShaderCodeProcessing.processCodeAfterIncludes(this.name, shaderType, code) : null,
        processFinalCode: customShaderCodeProcessing?.processFinalCode ? (shaderType, code) => customShaderCodeProcessing.processFinalCode(this.name, shaderType, code) : null,
        shaderLanguage: this.options.shaderLanguage,
        extraInitializationsAsync
      }, this.options.engine);
    } else {
      this._drawWrapper.effect = new Effect(this._shaderPath, this.options.attributeNames, uniforms || this.options.uniforms, samplers || this.options.samplerNames, this.options.engine, defines, void 0, onCompiled || this.options.onCompiled, void 0, void 0, void 0, this.options.shaderLanguage, extraInitializationsAsync);
    }
    this.onEffectCreatedObservable.notifyObservers(this._drawWrapper.effect);
  }
  /**
   * Binds the data to the effect.
   * @param noDefaultBindings if true, the default bindings (scale and alpha mode) will not be set.
   */
  bind(noDefaultBindings = false) {
    if (this.options.useAsPostProcess && !noDefaultBindings) {
      this.options.engine.setAlphaMode(this.alphaMode);
      this.drawWrapper.effect.setFloat2("scale", 1, 1);
    }
    _EffectWrapper._GetShaderCodeProcessing(this.name)?.bindCustomBindings?.(this.name, this._drawWrapper.effect);
  }
  /**
   * Disposes of the effect wrapper
   * @param _ignored kept for backward compatibility
   */
  dispose(_ignored = false) {
    if (this._onContextRestoredObserver) {
      this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
      this._onContextRestoredObserver = null;
    }
    this.onEffectCreatedObservable.clear();
    this._drawWrapper.dispose(true);
  }
};
EffectWrapper.ForceGLSL = false;
EffectWrapper._CustomShaderCodeProcessing = {};

export {
  Viewport,
  GetTypedArrayConstructor,
  GetTypedArrayData,
  CopyFloatData,
  Buffer,
  VertexBuffer,
  DrawWrapper,
  EffectRenderer,
  EffectWrapper
};
//# sourceMappingURL=chunk-TGS4FAHX.js.map
